#!/usr/bin/env python3
"""
Neo-Clone Superior TUI System - Enhanced Version
Revolutionary multi-panel interface with full skill integration
"""

import asyncio
import logging
import time
import json
import os
import sys
import importlib.util
import traceback
import hashlib
import threading
from typing import Dict, List, Any, Optional, Callable, Union
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from pathlib import Path
from collections import defaultdict, deque, OrderedDict
from functools import lru_cache
import weakref
from concurrent.futures import ThreadPoolExecutor
from contextlib import asynccontextmanager
from tui_components import ChatMessage, TUIConfig

# Try to import Rich, fallback to basic console if not available
try:
    from rich.console import Console
    from rich.layout import Layout
    from rich.panel import Panel
    from rich.text import Text
    from rich.table import Table
    from rich.tree import Tree
    from rich.progress import Progress, SpinnerColumn, TextColumn
    from rich.live import Live
    from rich.align import Align
    from rich.columns import Columns
    from rich.rule import Rule
    from rich.markdown import Markdown
    from rich.syntax import Syntax
    from rich.prompt import Prompt
    from rich import box
    from rich.spinner import Spinner
    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False
    # Mock rich classes for basic functionality
    class Console:
        def print(self, *args, **kwargs):
            print(*args, **kwargs)

        def rule(self, title=""):
            print(f"{'='*50} {title} {'='*50}")

    class Panel:
        def __init__(self, content, title=""):
            self.content = content
            self.title = title

        def __str__(self):
            return f"{self.title}\n{self.content}"

    class Table:
        def __init__(self, title=""):
            self.title = title
            self.rows = []

        def add_column(self, header, **kwargs):
            pass

        def add_row(self, *args):
            self.rows.append(args)

        def __str__(self):
            lines = [self.title] if self.title else []
            for row in self.rows:
                lines.append(" | ".join(str(cell) for cell in row))
            return "\n".join(lines)

    class Layout:
        def __init__(self, **kwargs):
            pass

        def split(self, *args, **kwargs):
            pass

        def __getitem__(self, key):
            return self

        def update(self, content):
            pass

    class Live:
        def __init__(self, layout, **kwargs):
            self.layout = layout

        def __enter__(self):
            return self

        def __exit__(self, *args):
            pass

    class Text:
        def __init__(self, content, **kwargs):
            self.content = content

        def __str__(self):
            return self.content

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ChatMessage class moved to separate module

class PerformanceMonitor:
    """Monitor system performance metrics"""

    def __init__(self):
        self.metrics = deque(maxlen=1000)
        self.start_time = time.time()

    def record_metric(self, name: str, value: float, tags: Dict[str, Any] = None):
        """Record a performance metric"""
        self.metrics.append({
            'name': name,
            'value': value,
            'timestamp': time.time(),
            'tags': tags or {}
        })

    def get_recent_metrics(self, name: str = None, minutes: int = 5) -> List[Dict]:
        """Get recent metrics"""
        cutoff = time.time() - (minutes * 60)
        metrics = [m for m in self.metrics if m['timestamp'] > cutoff]
        if name:
            metrics = [m for m in metrics if m['name'] == name]
        return metrics

    def get_performance_summary(self) -> Dict[str, Any]:
        """Get performance summary"""
        if not self.metrics:
            return {"status": "no_data"}

        recent = self.get_recent_metrics(minutes=1)
        summary = {
            "total_metrics": len(self.metrics),
            "recent_metrics": len(recent),
            "uptime_seconds": time.time() - self.start_time,
            "metrics_per_second": len(recent) / 60 if recent else 0
        }

        # Calculate averages by metric type
        metric_types = set(m['name'] for m in recent)
        for metric_type in metric_types:
            type_metrics = [m for m in recent if m['name'] == metric_type]
            if type_metrics:
                values = [m['value'] for m in type_metrics]
                summary[f"{metric_type}_avg"] = sum(values) / len(values)
                summary[f"{metric_type}_min"] = min(values)
                summary[f"{metric_type}_max"] = max(values)

        return summary

class RealTimeUpdater:
    """Handle real-time updates and notifications"""

    def __init__(self):
        self.subscribers = defaultdict(list)
        self.update_queue = asyncio.Queue()
        self.running = False

    async def start(self):
        """Start the real-time updater"""
        self.running = True
        asyncio.create_task(self._update_loop())

    async def stop(self):
        """Stop the real-time updater"""
        self.running = False

    def subscribe(self, event_type: str, callback: Callable):
        """Subscribe to real-time events"""
        self.subscribers[event_type].append(callback)

    async def publish(self, event_type: str, data: Any):
        """Publish an event to subscribers"""
        await self.update_queue.put((event_type, data))

    async def _update_loop(self):
        """Main update loop"""
        while self.running:
            try:
                event_type, data = await asyncio.wait_for(self.update_queue.get(), timeout=1.0)
                for callback in self.subscribers[event_type]:
                    try:
                        await callback(data)
                    except Exception as e:
                        logger.error(f"Error in real-time callback: {e}")
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Error in update loop: {e}")

class SuggestionEngine:
    """Provide intelligent suggestions and auto-completions"""

    def __init__(self):
        self.command_history = deque(maxlen=1000)
        self.skill_usage_patterns = defaultdict(int)
        self.context_patterns = defaultdict(list)

    def add_command(self, command: str, context: Dict[str, Any] = None):
        """Add a command to history for learning"""
        self.command_history.append({
            'command': command,
            'context': context or {},
            'timestamp': time.time()
        })

        # Update patterns
        words = command.lower().split()
        for word in words:
            if len(word) > 2:
                self.skill_usage_patterns[word] += 1

    def get_suggestions(self, partial_command: str, context: Dict[str, Any] = None) -> List[str]:
        """Get suggestions based on partial command"""
        suggestions = []

        # Command completion
        partial_lower = partial_command.lower()
        for cmd in self.command_history:
            if cmd['command'].lower().startswith(partial_lower):
                suggestions.append(cmd['command'])

        # Skill-based suggestions
        if 'use' in partial_lower or 'run' in partial_lower:
            suggestions.extend([
                "use code_generation",
                "use text_analysis",
                "use data_inspector",
                "use autonomous_code_review"
            ])

        # Context-aware suggestions
        if context and context.get('current_file'):
            file_ext = Path(context['current_file']).suffix
            if file_ext == '.py':
                suggestions.extend([
                    "review this Python file",
                    "analyze code quality",
                    "generate unit tests"
                ])

        return list(set(suggestions))[:5]  # Remove duplicates and limit

    def get_popular_commands(self, limit: int = 5) -> List[str]:
        """Get most popular commands"""
        command_counts = defaultdict(int)
        for cmd in self.command_history:
            command_counts[cmd['command']] += 1

        return sorted(command_counts.items(), key=lambda x: x[1], reverse=True)[:limit]

class VoiceProcessor:
    """Handle voice input and output"""

    def __init__(self):
        self.enabled = False
        self.listening = False

    async def start_listening(self) -> str:
        """Start voice listening (placeholder)"""
        # In a real implementation, this would use speech recognition
        self.listening = True
        # Simulate voice input
        await asyncio.sleep(2)  # Simulate processing time
        self.listening = False
        return "Voice input simulated: 'Hello Neo-Clone'"

    def speak(self, text: str):
        """Convert text to speech (placeholder)"""
        # In a real implementation, this would use TTS
        logger.info(f"TTS: {text}")

    def is_listening(self) -> bool:
        return self.listening

# TUIConfig and ChatMessage imported from tui_components

@dataclass
class SkillInfo:
    """Skill information structure"""
    name: str
    file_path: str
    description: str
    loaded: bool = False
    module: Optional[Any] = None
    functions: List[str] = None
    last_used: Optional[datetime] = None
    usage_count: int = 0

class SkillManager:
    """Manages loading and execution of Neo-Clone skills"""
    
    def __init__(self, skills_dir: str = "skills"):
        self.skills_dir = Path(skills_dir)
        self.skills: Dict[str, SkillInfo] = {}
        self.console = Console()
        self._load_all_skills()
    
    def _load_all_skills(self):
        """Load all available skills"""
        if not self.skills_dir.exists():
            logger.warning(f"Skills directory {self.skills_dir} not found")
            return
        
        for skill_file in self.skills_dir.glob("*.py"):
            if skill_file.name == "__init__.py":
                continue
            
            skill_name = skill_file.stem
            try:
                # Load the module
                spec = importlib.util.spec_from_file_location(skill_name, skill_file)
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
                    
                    # Extract description
                    description = self._extract_description(module)
                    functions = self._extract_functions(module)
                    
                    skill_info = SkillInfo(
                        name=skill_name,
                        file_path=str(skill_file),
                        description=description,
                        loaded=True,
                        module=module,
                        functions=functions
                    )
                    
                    self.skills[skill_name] = skill_info
                    logger.info(f"Loaded skill: {skill_name}")
                    
            except Exception as e:
                logger.error(f"Failed to load skill {skill_name}: {e}")
                # Still add skill info but mark as not loaded
                self.skills[skill_name] = SkillInfo(
                    name=skill_name,
                    file_path=str(skill_file),
                    description=f"Failed to load: {str(e)}",
                    loaded=False
                )
    
    def _extract_description(self, module) -> str:
        """Extract description from module docstring"""
        if hasattr(module, '__doc__') and module.__doc__:
            return module.__doc__.strip().split('\n')[0]
        return "No description available"
    
    def _extract_functions(self, module) -> List[str]:
        """Extract callable functions from module"""
        functions = []
        for name in dir(module):
            obj = getattr(module, name)
            if callable(obj) and not name.startswith('_'):
                functions.append(name)
        return functions
    
    def get_skill(self, name: str) -> Optional[SkillInfo]:
        """Get skill by name"""
        return self.skills.get(name)
    
    def list_skills(self) -> List[SkillInfo]:
        """List all available skills"""
        return list(self.skills.values())
    
    async def execute_skill(self, skill_name: str, function_name: str, *args, **kwargs) -> Any:
        """Execute a skill function"""
        skill = self.get_skill(skill_name)
        if not skill or not skill.loaded:
            raise ValueError(f"Skill {skill_name} not available")
        
        if not hasattr(skill.module, function_name):
            raise ValueError(f"Function {function_name} not found in skill {skill_name}")
        
        func = getattr(skill.module, function_name)
        
        # Update usage stats
        skill.last_used = datetime.now()
        skill.usage_count += 1
        
        try:
            # Execute function with timeout
            if asyncio.iscoroutinefunction(func):
                result = await asyncio.wait_for(func(*args, **kwargs), timeout=30.0)
            else:
                result = func(*args, **kwargs)
            
            return result
            
        except asyncio.TimeoutError:
            raise TimeoutError(f"Skill {skill_name}.{function_name} timed out")
        except Exception as e:
            logger.error(f"Error executing {skill_name}.{function_name}: {e}")
            raise

class MultiLevelCache:
    """Multi-level caching with LRU and TTL strategies"""

    def __init__(self, max_memory_items: int = 1000, max_disk_items: int = 10000):
        self.memory_cache = OrderedDict()
        self.disk_cache_path = Path(".neo_cache")
        self.disk_cache_path.mkdir(exist_ok=True)
        self.max_memory_items = max_memory_items
        self.max_disk_items = max_disk_items
        self.ttl_cache = {}  # For TTL-based expiration
        self._lock = threading.RLock()

    def get(self, key: str) -> Optional[Any]:
        """Get item from cache with fallback to disk"""
        with self._lock:
            # Check memory cache first
            if key in self.memory_cache:
                # Move to end (most recently used)
                value, expiry = self.memory_cache.pop(key)
                if expiry is None or time.time() < expiry:
                    self.memory_cache[key] = (value, expiry)
                    return value
                else:
                    # Expired, remove it
                    del self.memory_cache[key]

            # Check disk cache
            disk_file = self.disk_cache_path / f"{hashlib.md5(key.encode()).hexdigest()}.json"
            if disk_file.exists():
                try:
                    with open(disk_file, 'r') as f:
                        data = json.load(f)
                        if data.get('expiry') is None or time.time() < data['expiry']:
                            value = data['value']
                            # Promote to memory cache
                            self.set(key, value, ttl=data.get('ttl'))
                            return value
                        else:
                            # Expired, remove file
                            disk_file.unlink()
                except Exception as e:
                    logger.warning(f"Error reading disk cache for {key}: {e}")

            return None

    def set(self, key: str, value: Any, ttl: Optional[int] = None):
        """Set item in cache"""
        with self._lock:
            expiry = time.time() + ttl if ttl else None

            # Set in memory cache
            if len(self.memory_cache) >= self.max_memory_items:
                # Remove least recently used
                self.memory_cache.popitem(last=False)

            self.memory_cache[key] = (value, expiry)

            # Also save to disk for persistence
            try:
                disk_file = self.disk_cache_path / f"{hashlib.md5(key.encode()).hexdigest()}.json"
                data = {
                    'value': value,
                    'expiry': expiry,
                    'ttl': ttl,
                    'timestamp': time.time()
                }
                with open(disk_file, 'w') as f:
                    json.dump(data, f)

                # Clean up old disk cache files if needed
                self._cleanup_disk_cache()

            except Exception as e:
                logger.warning(f"Error writing to disk cache for {key}: {e}")

    def _cleanup_disk_cache(self):
        """Clean up old disk cache files"""
        try:
            cache_files = list(self.disk_cache_path.glob("*.json"))
            if len(cache_files) > self.max_disk_items:
                # Sort by modification time, remove oldest
                cache_files.sort(key=lambda x: x.stat().st_mtime)
                for old_file in cache_files[:len(cache_files) - self.max_disk_items]:
                    old_file.unlink()
        except Exception as e:
            logger.warning(f"Error cleaning disk cache: {e}")

    def clear(self):
        """Clear all caches"""
        with self._lock:
            self.memory_cache.clear()
            try:
                for cache_file in self.disk_cache_path.glob("*.json"):
                    cache_file.unlink()
            except Exception as e:
                logger.warning(f"Error clearing disk cache: {e}")

class ResourcePool:
    """Resource pooling for managing connections and objects"""

    def __init__(self, factory: Callable, max_size: int = 10, min_size: int = 1):
        self.factory = factory
        self.max_size = max_size
        self.min_size = min_size
        self.pool = deque()
        self.in_use = set()
        self._lock = threading.RLock()
        self._initialize_pool()

    def _initialize_pool(self):
        """Initialize minimum pool size"""
        for _ in range(self.min_size):
            try:
                resource = self.factory()
                self.pool.append(resource)
            except Exception as e:
                logger.warning(f"Error creating resource for pool: {e}")

    def acquire(self) -> Any:
        """Acquire a resource from the pool"""
        with self._lock:
            if self.pool:
                resource = self.pool.popleft()
                self.in_use.add(id(resource))
                return resource
            elif len(self.in_use) < self.max_size:
                try:
                    resource = self.factory()
                    self.in_use.add(id(resource))
                    return resource
                except Exception as e:
                    logger.error(f"Error creating new resource: {e}")
                    raise
            else:
                raise RuntimeError("Resource pool exhausted")

    def release(self, resource: Any):
        """Release a resource back to the pool"""
        with self._lock:
            resource_id = id(resource)
            if resource_id in self.in_use:
                self.in_use.remove(resource_id)
                if len(self.pool) < self.max_size:
                    self.pool.append(resource)
                else:
                    # Pool is full, cleanup resource if possible
                    if hasattr(resource, 'close'):
                        try:
                            resource.close()
                        except Exception:
                            pass

    @asynccontextmanager
    async def get_resource(self):
        """Async context manager for resource acquisition"""
        resource = await asyncio.get_event_loop().run_in_executor(None, self.acquire)
        try:
            yield resource
        finally:
            await asyncio.get_event_loop().run_in_executor(None, self.release, resource)

class AsyncIOManager:
    """Asynchronous I/O operations manager"""

    def __init__(self, max_workers: int = 4):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.loop = None

    async def run_io_operation(self, func: Callable, *args, **kwargs) -> Any:
        """Run blocking I/O operation asynchronously"""
        if self.loop is None:
            self.loop = asyncio.get_event_loop()

        return await self.loop.run_in_executor(self.executor, func, *args, **kwargs)

    async def read_file_async(self, file_path: Union[str, Path], encoding: str = 'utf-8') -> str:
        """Asynchronously read a file"""
        def _read():
            with open(file_path, 'r', encoding=encoding) as f:
                return f.read()
        return await self.run_io_operation(_read)

    async def write_file_async(self, file_path: Union[str, Path], content: str, encoding: str = 'utf-8'):
        """Asynchronously write a file"""
        def _write():
            with open(file_path, 'w', encoding=encoding) as f:
                f.write(content)
        await self.run_io_operation(_write)

    async def list_dir_async(self, path: Union[str, Path]) -> List[Path]:
        """Asynchronously list directory contents"""
        def _list():
            return list(Path(path).iterdir())
        return await self.run_io_operation(_list)

class DependencyInjector:
    """Simple dependency injection container"""

    def __init__(self):
        self.services = {}
        self.factories = {}
        self.singletons = {}

    def register(self, interface: type, implementation: type, singleton: bool = True):
        """Register a service implementation"""
        self.services[interface] = implementation
        if singleton:
            self.singletons[interface] = None

    def register_factory(self, interface: type, factory: Callable):
        """Register a factory function"""
        self.factories[interface] = factory

    def resolve(self, interface: type) -> Any:
        """Resolve a service instance"""
        if interface in self.singletons and self.singletons[interface] is not None:
            return self.singletons[interface]

        if interface in self.factories:
            instance = self.factories[interface]()
        elif interface in self.services:
            impl = self.services[interface]
            instance = impl()
        else:
            raise ValueError(f"No registration found for {interface}")

        if interface in self.singletons:
            self.singletons[interface] = instance

        return instance

class EventManager:
    """Manages events and communication between components"""

    def __init__(self):
        self.listeners: Dict[str, List[Callable]] = defaultdict(list)
        self.event_queue = asyncio.Queue()
        self.running = False
        self.event_history = deque(maxlen=1000)  # For debugging/auditing

    def subscribe(self, event_type: str, callback: Callable):
        """Subscribe to an event type"""
        self.listeners[event_type].append(callback)

    def unsubscribe(self, event_type: str, callback: Callable):
        """Unsubscribe from an event type"""
        if callback in self.listeners[event_type]:
            self.listeners[event_type].remove(callback)

    async def emit(self, event_type: str, data: Any = None):
        """Emit an event"""
        event = {
            'type': event_type,
            'data': data,
            'timestamp': datetime.now(),
            'id': hashlib.md5(f"{event_type}_{time.time()}".encode()).hexdigest()[:8]
        }
        self.event_history.append(event)
        await self.event_queue.put(event)

    async def process_events(self):
        """Process events from the queue"""
        self.running = True
        while self.running:
            try:
                event = await asyncio.wait_for(self.event_queue.get(), timeout=0.1)
                event_type = event['type']
                data = event['data']

                # Notify all listeners
                for callback in self.listeners.get(event_type, []):
                    try:
                        if asyncio.iscoroutinefunction(callback):
                            await callback(event)
                        else:
                            callback(event)
                    except Exception as e:
                        logger.error(f"Error in event callback: {e}")

            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Error processing events: {e}")

    def get_event_history(self, event_type: Optional[str] = None, limit: int = 100) -> List[Dict]:
        """Get event history for auditing"""
        history = list(self.event_history)
        if event_type:
            history = [e for e in history if e['type'] == event_type]
        return history[-limit:]

class ModelEnsemble:
    """Model ensemble for combining multiple AI models"""

    def __init__(self):
        self.models = {}
        self.model_weights = {}
        self.performance_history = defaultdict(list)
        self.ensemble_cache = MultiLevelCache(max_memory_items=500)

    def add_model(self, name: str, model_instance: Any, weight: float = 1.0):
        """Add a model to the ensemble"""
        self.models[name] = model_instance
        self.model_weights[name] = weight

    async def predict_ensemble(self, prompt: str, task_type: str = "general") -> Dict[str, Any]:
        """Get ensemble prediction with voting/confidence scoring"""
        cache_key = f"ensemble_{hashlib.md5(prompt.encode()).hexdigest()}_{task_type}"

        # Check cache first
        cached_result = self.ensemble_cache.get(cache_key)
        if cached_result:
            return cached_result

        if not self.models:
            raise ValueError("No models in ensemble")

        # Run predictions in parallel
        tasks = []
        for name, model in self.models.items():
            tasks.append(self._run_model_prediction(name, model, prompt, task_type))

        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Process results
        valid_results = []
        for i, result in enumerate(results):
            model_name = list(self.models.keys())[i]
            if isinstance(result, Exception):
                logger.warning(f"Model {model_name} failed: {result}")
                continue

            valid_results.append({
                'model': model_name,
                'result': result,
                'weight': self.model_weights.get(model_name, 1.0),
                'confidence': self._calculate_confidence(result)
            })

        if not valid_results:
            raise RuntimeError("All models in ensemble failed")

        # Ensemble decision making
        ensemble_result = self._combine_results(valid_results, task_type)

        # Cache result
        self.ensemble_cache.set(cache_key, ensemble_result, ttl=3600)  # 1 hour TTL

        # Update performance history
        self._update_performance_history(task_type, valid_results)

        return ensemble_result

    async def _run_model_prediction(self, name: str, model: Any, prompt: str, task_type: str) -> Dict[str, Any]:
        """Run prediction for a single model"""
        try:
            # This would need to be adapted based on actual model interfaces
            if hasattr(model, 'generate_response'):
                return await model.generate_response(prompt)
            elif hasattr(model, 'predict'):
                return await model.predict(prompt)
            else:
                # Fallback for different model types
                return {"response": f"Model {name} response placeholder", "confidence": 0.5}
        except Exception as e:
            logger.error(f"Error in model {name}: {e}")
            raise

    def _calculate_confidence(self, result: Dict[str, Any]) -> float:
        """Calculate confidence score for a result"""
        # Simple confidence calculation - can be enhanced
        if 'confidence' in result:
            return result['confidence']
        elif 'score' in result:
            return min(result['score'] / 100, 1.0)
        else:
            return 0.5  # Default confidence

    def _combine_results(self, results: List[Dict], task_type: str) -> Dict[str, Any]:
        """Combine results from multiple models"""
        if task_type == "classification":
            return self._vote_classification(results)
        elif task_type == "generation":
            return self._combine_generation(results)
        else:
            return self._weighted_average(results)

    def _vote_classification(self, results: List[Dict]) -> Dict[str, Any]:
        """Voting for classification tasks"""
        votes = defaultdict(float)
        total_weight = sum(r['weight'] for r in results)

        for result in results:
            response = result['result'].get('response', '')
            weight = result['weight']
            confidence = result['confidence']
            votes[response] += weight * confidence

        # Get winner
        winner = max(votes.items(), key=lambda x: x[1])
        confidence = winner[1] / total_weight if total_weight > 0 else 0

        return {
            "response": winner[0],
            "confidence": confidence,
            "method": "voting",
            "model_contributions": {r['model']: r['result'].get('response') for r in results}
        }

    def _combine_generation(self, results: List[Dict]) -> Dict[str, Any]:
        """Combine generation results"""
        responses = [r['result'].get('response', '') for r in results]
        confidences = [r['confidence'] for r in results]
        weights = [r['weight'] for r in results]

        # Weighted combination - could use more sophisticated methods
        combined_response = max(responses, key=lambda x: len(x))  # Simple: pick longest
        avg_confidence = sum(c * w for c, w in zip(confidences, weights)) / sum(weights)

        return {
            "response": combined_response,
            "confidence": avg_confidence,
            "method": "generation_combine",
            "all_responses": responses
        }

    def _weighted_average(self, results: List[Dict]) -> Dict[str, Any]:
        """Weighted average for general tasks"""
        total_weight = sum(r['weight'] for r in results)
        weighted_response = ""
        total_confidence = 0

        for result in results:
            weight = result['weight']
            confidence = result['confidence']
            response = result['result'].get('response', '')

            weighted_response += response * (weight / total_weight)
            total_confidence += confidence * weight

        return {
            "response": weighted_response,
            "confidence": total_confidence / total_weight if total_weight > 0 else 0,
            "method": "weighted_average"
        }

    def _update_performance_history(self, task_type: str, results: List[Dict]):
        """Update performance history for adaptive learning"""
        for result in results:
            self.performance_history[task_type].append({
                'model': result['model'],
                'confidence': result['confidence'],
                'weight': result['weight'],
                'timestamp': time.time()
            })

            # Keep only recent history
            if len(self.performance_history[task_type]) > 100:
                self.performance_history[task_type] = self.performance_history[task_type][-100:]

class AdaptiveLearningEngine:
    """Adaptive learning system that improves over time"""

    def __init__(self):
        self.learning_patterns = defaultdict(list)
        self.user_preferences = {}
        self.skill_effectiveness = defaultdict(list)
        self.context_patterns = defaultdict(lambda: defaultdict(int))

    def learn_from_interaction(self, user_input: str, response: str, success: bool,
                              response_time: float, user_feedback: Optional[float] = None):
        """Learn from user interactions"""
        interaction = {
            'input': user_input,
            'response': response,
            'success': success,
            'response_time': response_time,
            'feedback': user_feedback,
            'timestamp': time.time()
        }

        # Extract patterns
        input_words = set(user_input.lower().split())
        for word in input_words:
            if len(word) > 3:  # Ignore short words
                self.learning_patterns[word].append(interaction)

        # Update skill effectiveness if response involved skills
        if 'skill' in response.lower():
            skill_match = self._extract_skill_from_response(response)
            if skill_match:
                self.skill_effectiveness[skill_match].append({
                    'success': success,
                    'response_time': response_time,
                    'feedback': user_feedback,
                    'timestamp': time.time()
                })

        # Update context patterns
        context = self._extract_context(user_input)
        for ctx in context:
            self.context_patterns[ctx]['total'] += 1
            if success:
                self.context_patterns[ctx]['success'] += 1

    def _extract_skill_from_response(self, response: str) -> Optional[str]:
        """Extract skill name from response"""
        import re
        match = re.search(r'skill[:\s]+(\w+)', response, re.IGNORECASE)
        return match.group(1) if match else None

    def _extract_context(self, user_input: str) -> List[str]:
        """Extract context keywords from input"""
        contexts = []
        input_lower = user_input.lower()

        if any(word in input_lower for word in ['code', 'programming', 'function', 'class']):
            contexts.append('coding')
        if any(word in input_lower for word in ['analyze', 'analysis', 'data']):
            contexts.append('analysis')
        if any(word in input_lower for word in ['help', 'how', 'what']):
            contexts.append('help')
        if any(word in input_lower for word in ['file', 'directory', 'folder']):
            contexts.append('file_management')

        return contexts

    def get_optimal_strategy(self, user_input: str) -> Dict[str, Any]:
        """Get optimal response strategy based on learning"""
        input_lower = user_input.lower()
        words = set(input_lower.split())

        # Find similar past interactions
        similar_interactions = []
        for word in words:
            if word in self.learning_patterns:
                similar_interactions.extend(self.learning_patterns[word])

        if not similar_interactions:
            return {"strategy": "default", "confidence": 0.5}

        # Analyze successful patterns
        successful = [i for i in similar_interactions if i['success']]
        if successful:
            avg_response_time = sum(i['response_time'] for i in successful) / len(successful)
            avg_feedback = sum(i['feedback'] for i in successful if i['feedback']) / len([i for i in successful if i['feedback']]) if any(i['feedback'] for i in successful) else None

            return {
                "strategy": "learned",
                "confidence": len(successful) / len(similar_interactions),
                "avg_response_time": avg_response_time,
                "avg_feedback": avg_feedback,
                "sample_responses": [i['response'] for i in successful[:3]]
            }

        return {"strategy": "default", "confidence": 0.3}

    def get_recommended_skills(self, context: str, limit: int = 3) -> List[str]:
        """Get recommended skills based on context"""
        if context not in self.context_patterns:
            return []

        # Get skills that performed well in this context
        skill_scores = {}
        for skill, interactions in self.skill_effectiveness.items():
            context_interactions = [i for i in interactions if self._interaction_in_context(i, context)]
            if context_interactions:
                success_rate = sum(1 for i in context_interactions if i['success']) / len(context_interactions)
                avg_feedback = sum(i['feedback'] for i in context_interactions if i['feedback'] is not None) / len([i for i in context_interactions if i['feedback'] is not None]) if any(i['feedback'] is not None for i in context_interactions) else 0
                skill_scores[skill] = success_rate * 0.7 + avg_feedback * 0.3

        return sorted(skill_scores.items(), key=lambda x: x[1], reverse=True)[:limit]

    def _interaction_in_context(self, interaction: Dict, context: str) -> bool:
        """Check if interaction occurred in given context"""
        # This would need more sophisticated context tracking
        return True  # Placeholder

class RecommendationEngine:
    """Intelligent recommendation engine"""

    def __init__(self):
        self.user_history = defaultdict(list)
        self.item_similarities = {}
        self.collaborative_data = defaultdict(lambda: defaultdict(float))

    def add_user_interaction(self, user_id: str, item: str, rating: float, context: Dict = None):
        """Add user interaction for recommendations"""
        self.user_history[user_id].append({
            'item': item,
            'rating': rating,
            'context': context or {},
            'timestamp': time.time()
        })

    def get_recommendations(self, user_id: str, item_type: str = "skill", limit: int = 5) -> List[Dict]:
        """Get personalized recommendations"""
        if user_id not in self.user_history:
            return self._get_popular_items(item_type, limit)

        user_items = [i['item'] for i in self.user_history[user_id]]
        user_ratings = {i['item']: i['rating'] for i in self.user_history[user_id]}

        # Collaborative filtering
        recommendations = []
        for item in self._get_all_items(item_type):
            if item in user_items:
                continue

            similarity_score = self._calculate_item_similarity(user_ratings, item)
            if similarity_score > 0:
                recommendations.append({
                    'item': item,
                    'score': similarity_score,
                    'reason': 'similar_to_liked'
                })

        # Sort and return top recommendations
        recommendations.sort(key=lambda x: x['score'], reverse=True)
        return recommendations[:limit]

    def _calculate_item_similarity(self, user_ratings: Dict[str, float], item: str) -> float:
        """Calculate similarity between user's preferences and item"""
        # Simple collaborative filtering
        item_users = self.collaborative_data[item]
        similarity = 0
        total_weight = 0

        for rated_item, rating in user_ratings.items():
            if rated_item in self.collaborative_data:
                rated_item_users = self.collaborative_data[rated_item]
                common_users = set(item_users.keys()) & set(rated_item_users.keys())

                if common_users:
                    # Cosine similarity
                    dot_product = sum(item_users[u] * rated_item_users[u] for u in common_users)
                    norm_a = sum(v**2 for v in item_users.values()) ** 0.5
                    norm_b = sum(v**2 for v in rated_item_users.values()) ** 0.5

                    if norm_a and norm_b:
                        cos_sim = dot_product / (norm_a * norm_b)
                        similarity += cos_sim * rating
                        total_weight += abs(rating)

        return similarity / total_weight if total_weight > 0 else 0

    def _get_all_items(self, item_type: str) -> List[str]:
        """Get all available items of a type"""
        if item_type == "skill":
            return ["code_generation", "text_analysis", "file_manager", "data_inspector", "autonomous_intelligence"]
        return []

    def _get_popular_items(self, item_type: str, limit: int) -> List[Dict]:
        """Get popular items when no user history"""
        popular_items = self._get_all_items(item_type)
        return [{'item': item, 'score': 0.5, 'reason': 'popular'} for item in popular_items[:limit]]

class AuditLogger:
    """Comprehensive audit logging and compliance tracking"""

    def __init__(self, log_file: str = "neo_clone_audit.log"):
        self.log_file = Path(log_file)
        self.log_queue = asyncio.Queue()
        self.running = False
        self.encryption_key = None  # For encrypted logging if needed

    async def start(self):
        """Start the audit logging service"""
        self.running = True
        asyncio.create_task(self._log_processor())

    async def stop(self):
        """Stop the audit logging service"""
        self.running = False

    async def log_event(self, event_type: str, user: str, action: str,
                       resource: str, result: str, metadata: Dict = None):
        """Log an auditable event"""
        event = {
            'timestamp': datetime.now().isoformat(),
            'event_type': event_type,
            'user': user,
            'action': action,
            'resource': resource,
            'result': result,
            'metadata': metadata or {},
            'session_id': getattr(self, '_current_session', None),
            'ip_address': 'localhost',  # Would be actual IP in production
            'user_agent': 'Neo-Clone-TUI'
        }

        await self.log_queue.put(event)

    async def _log_processor(self):
        """Process and write log entries"""
        while self.running:
            try:
                event = await asyncio.wait_for(self.log_queue.get(), timeout=1.0)
                await self._write_log_entry(event)
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Error processing audit log: {e}")

    async def _write_log_entry(self, event: Dict):
        """Write log entry to file"""
        try:
            log_entry = json.dumps(event, default=str) + "\n"

            async with asyncio.Lock():  # File access lock
                with open(self.log_file, 'a', encoding='utf-8') as f:
                    f.write(log_entry)

        except Exception as e:
            logger.error(f"Error writing audit log entry: {e}")

    def get_audit_trail(self, user: Optional[str] = None, event_type: Optional[str] = None,
                       start_date: Optional[datetime] = None, end_date: Optional[datetime] = None,
                       limit: int = 100) -> List[Dict]:
        """Retrieve audit trail with filtering"""
        try:
            entries = []
            with open(self.log_file, 'r', encoding='utf-8') as f:
                for line in f:
                    try:
                        entry = json.loads(line.strip())
                        entries.append(entry)
                    except json.JSONDecodeError:
                        continue

            # Apply filters
            filtered = entries
            if user:
                filtered = [e for e in filtered if e.get('user') == user]
            if event_type:
                filtered = [e for e in filtered if e.get('event_type') == event_type]
            if start_date:
                filtered = [e for e in filtered if datetime.fromisoformat(e['timestamp']) >= start_date]
            if end_date:
                filtered = [e for e in filtered if datetime.fromisoformat(e['timestamp']) <= end_date]

            return filtered[-limit:]

        except Exception as e:
            logger.error(f"Error retrieving audit trail: {e}")
            return []

class RateLimiter:
    """Rate limiting for API calls and user actions"""

    def __init__(self, requests_per_minute: int = 60, burst_limit: int = 10):
        self.requests_per_minute = requests_per_minute
        self.burst_limit = burst_limit
        self.user_requests = defaultdict(deque)
        self.ip_requests = defaultdict(deque)
        self._lock = threading.RLock()

    def is_allowed(self, user_id: str, ip_address: str = "localhost") -> bool:
        """Check if request is allowed"""
        with self._lock:
            now = time.time()
            window_start = now - 60  # 1 minute window

            # Clean old requests
            self._clean_old_requests(user_id, ip_address, window_start)

            # Check user rate limit
            user_count = len(self.user_requests[user_id])
            ip_count = len(self.ip_requests[ip_address])

            if user_count >= self.requests_per_minute or ip_count >= self.requests_per_minute:
                return False

            # Check burst limit
            recent_user = sum(1 for t in self.user_requests[user_id] if t > now - 10)  # Last 10 seconds
            if recent_user >= self.burst_limit:
                return False

            # Record request
            self.user_requests[user_id].append(now)
            self.ip_requests[ip_address].append(now)

            return True

    def _clean_old_requests(self, user_id: str, ip_address: str, window_start: float):
        """Clean requests outside the time window"""
        self.user_requests[user_id] = deque(t for t in self.user_requests[user_id] if t > window_start)
        self.ip_requests[ip_address] = deque(t for t in self.ip_requests[ip_address] if t > window_start)

    def get_remaining_requests(self, user_id: str) -> int:
        """Get remaining requests for user"""
        with self._lock:
            now = time.time()
            window_start = now - 60
            self._clean_old_requests(user_id, "dummy", window_start)
            return max(0, self.requests_per_minute - len(self.user_requests[user_id]))

class SessionManager:
    """Session management for user interactions"""

    def __init__(self, session_timeout: int = 3600):  # 1 hour default
        self.sessions = {}
        self.session_timeout = session_timeout
        self.session_data = {}
        self._lock = threading.RLock()

    def create_session(self, user_id: str, metadata: Dict = None) -> str:
        """Create a new session"""
        with self._lock:
            session_id = hashlib.md5(f"{user_id}_{time.time()}".encode()).hexdigest()
            self.sessions[session_id] = {
                'user_id': user_id,
                'created_at': time.time(),
                'last_activity': time.time(),
                'metadata': metadata or {},
                'active': True
            }
            self.session_data[session_id] = {}
            return session_id

    def get_session(self, session_id: str) -> Optional[Dict]:
        """Get session information"""
        with self._lock:
            if session_id not in self.sessions:
                return None

            session = self.sessions[session_id]
            if not session['active'] or time.time() - session['last_activity'] > self.session_timeout:
                self._cleanup_session(session_id)
                return None

            session['last_activity'] = time.time()
            return session

    def update_session_data(self, session_id: str, key: str, value: Any):
        """Update session data"""
        with self._lock:
            if session_id in self.session_data:
                self.session_data[session_id][key] = value

    def get_session_data(self, session_id: str, key: str = None) -> Any:
        """Get session data"""
        with self._lock:
            if session_id not in self.session_data:
                return None
            data = self.session_data[session_id]
            return data.get(key) if key else data

    def end_session(self, session_id: str):
        """End a session"""
        with self._lock:
            self._cleanup_session(session_id)

    def _cleanup_session(self, session_id: str):
        """Clean up session data"""
        if session_id in self.sessions:
            del self.sessions[session_id]
        if session_id in self.session_data:
            del self.session_data[session_id]

    def cleanup_expired_sessions(self):
        """Clean up expired sessions"""
        with self._lock:
            now = time.time()
            expired = []
            for session_id, session in self.sessions.items():
                if not session['active'] or now - session['last_activity'] > self.session_timeout:
                    expired.append(session_id)

            for session_id in expired:
                self._cleanup_session(session_id)

class InputValidator:
    """Comprehensive input validation"""

    def __init__(self):
        self.max_input_length = 10000
        self.forbidden_patterns = [
            r'<script[^>]*>.*?</script>',  # XSS attempts
            r'union\s+select',  # SQL injection
            r';\s*rm\s',  # Dangerous commands
            r'eval\s*\(',  # Code execution
        ]
        self.allowed_file_extensions = {'.py', '.js', '.ts', '.md', '.txt', '.json', '.yaml', '.yml'}

    def validate_input(self, input_text: str, input_type: str = "text") -> Dict[str, Any]:
        """Validate input and return validation result"""
        result = {
            'valid': True,
            'errors': [],
            'warnings': [],
            'sanitized_input': input_text
        }

        # Length check
        if len(input_text) > self.max_input_length:
            result['valid'] = False
            result['errors'].append(f"Input too long: {len(input_text)} > {self.max_input_length}")

        # Pattern checks
        for pattern in self.forbidden_patterns:
            import re
            if re.search(pattern, input_text, re.IGNORECASE):
                result['valid'] = False
                result['errors'].append(f"Potentially dangerous pattern detected: {pattern}")

        # Type-specific validation
        if input_type == "file_path":
            result.update(self._validate_file_path(input_text))
        elif input_type == "command":
            result.update(self._validate_command(input_text))
        elif input_type == "code":
            result.update(self._validate_code(input_text))

        # Sanitization
        result['sanitized_input'] = self._sanitize_input(input_text)

        return result

    def _validate_file_path(self, path: str) -> Dict[str, Any]:
        """Validate file path"""
        result = {'valid': True, 'errors': [], 'warnings': []}

        try:
            p = Path(path)
            if p.is_absolute() and not str(p).startswith(str(Path.cwd())):
                result['warnings'].append("Absolute path outside current directory")

            if p.exists() and p.is_file():
                ext = p.suffix.lower()
                if ext not in self.allowed_file_extensions:
                    result['warnings'].append(f"File extension '{ext}' not in allowed list")

        except Exception as e:
            result['errors'].append(f"Invalid path: {e}")

        return result

    def _validate_command(self, command: str) -> Dict[str, Any]:
        """Validate command input"""
        result = {'valid': True, 'errors': [], 'warnings': []}

        dangerous_commands = ['rm', 'del', 'format', 'fdisk', 'mkfs']
        cmd_lower = command.lower()

        for dangerous in dangerous_commands:
            if dangerous in cmd_lower:
                result['warnings'].append(f"Potentially dangerous command: {dangerous}")

        return result

    def _validate_code(self, code: str) -> Dict[str, Any]:
        """Validate code input"""
        result = {'valid': True, 'errors': [], 'warnings': []}

        # Basic syntax check for Python
        if 'python' in code.lower() or code.strip().startswith(('def ', 'class ', 'import ')):
            try:
                compile(code, '<string>', 'exec')
            except SyntaxError as e:
                result['errors'].append(f"Syntax error: {e}")

        return result

    def _sanitize_input(self, input_text: str) -> str:
        """Sanitize input to prevent injection attacks"""
        # Basic sanitization - remove or escape dangerous characters
        import re
        import html

        # HTML escape
        sanitized = html.escape(input_text)

        # Remove null bytes
        sanitized = sanitized.replace('\x00', '')

        return sanitized

class CircuitBreaker:
    """Circuit breaker pattern for fault tolerance"""

    def __init__(self, failure_threshold: int = 5, recovery_timeout: int = 60, expected_exception: Exception = Exception):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.expected_exception = expected_exception
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
        self._lock = threading.RLock()

    async def call(self, func: Callable, *args, **kwargs) -> Any:
        """Execute function with circuit breaker protection"""
        with self._lock:
            if self.state == "OPEN":
                if time.time() - self.last_failure_time > self.recovery_timeout:
                    self.state = "HALF_OPEN"
                else:
                    raise CircuitBreakerOpenException("Circuit breaker is OPEN")

            try:
                result = await func(*args, **kwargs) if asyncio.iscoroutinefunction(func) else func(*args, **kwargs)
                self._on_success()
                return result
            except self.expected_exception as e:
                self._on_failure()
                raise
            except Exception as e:
                # Unexpected exception, don't count as failure for circuit breaker
                raise

    def _on_success(self):
        """Handle successful call"""
        if self.state == "HALF_OPEN":
            self.state = "CLOSED"
            self.failure_count = 0

    def _on_failure(self):
        """Handle failed call"""
        self.failure_count += 1
        self.last_failure_time = time.time()

        if self.failure_count >= self.failure_threshold:
            self.state = "OPEN"

    def get_state(self) -> Dict[str, Any]:
        """Get current circuit breaker state"""
        return {
            'state': self.state,
            'failure_count': self.failure_count,
            'last_failure_time': self.last_failure_time,
            'time_since_last_failure': time.time() - (self.last_failure_time or 0)
        }

class CircuitBreakerOpenException(Exception):
    """Exception raised when circuit breaker is open"""
    pass

class GracefulDegradationManager:
    """Manages graceful degradation when services fail"""

    def __init__(self):
        self.service_status = {}
        self.degradation_strategies = {}
        self.fallback_services = {}

    def register_service(self, service_name: str, health_check: Callable, degradation_strategy: str = "fallback"):
        """Register a service with health monitoring"""
        self.service_status[service_name] = {
            'healthy': True,
            'last_check': time.time(),
            'failure_count': 0
        }
        self.degradation_strategies[service_name] = degradation_strategy

    def set_fallback(self, service_name: str, fallback_func: Callable):
        """Set fallback function for a service"""
        self.fallback_services[service_name] = fallback_func

    async def execute_with_degradation(self, service_name: str, func: Callable, *args, **kwargs) -> Any:
        """Execute function with graceful degradation"""
        service_status = self.service_status.get(service_name, {})

        if not service_status.get('healthy', True):
            # Service is degraded, use fallback
            return await self._use_fallback(service_name, *args, **kwargs)

        try:
            result = await func(*args, **kwargs) if asyncio.iscoroutinefunction(func) else func(*args, **kwargs)
            self._update_service_health(service_name, True)
            return result
        except Exception as e:
            self._update_service_health(service_name, False)
            logger.warning(f"Service {service_name} failed, using fallback: {e}")
            return await self._use_fallback(service_name, *args, **kwargs)

    async def _use_fallback(self, service_name: str, *args, **kwargs) -> Any:
        """Use fallback for degraded service"""
        if service_name in self.fallback_services:
            fallback_func = self.fallback_services[service_name]
            return await fallback_func(*args, **kwargs) if asyncio.iscoroutinefunction(fallback_func) else fallback_func(*args, **kwargs)
        else:
            # Default fallback
            return {"status": "degraded", "message": f"Service {service_name} is currently unavailable", "fallback": True}

    def _update_service_health(self, service_name: str, healthy: bool):
        """Update service health status"""
        if service_name not in self.service_status:
            return

        status = self.service_status[service_name]
        status['last_check'] = time.time()

        if healthy:
            status['healthy'] = True
            status['failure_count'] = 0
        else:
            status['failure_count'] += 1
            if status['failure_count'] >= 3:  # Threshold for marking unhealthy
                status['healthy'] = False

    def get_system_health(self) -> Dict[str, Any]:
        """Get overall system health"""
        total_services = len(self.service_status)
        healthy_services = sum(1 for s in self.service_status.values() if s['healthy'])
        degraded_services = total_services - healthy_services

        return {
            'total_services': total_services,
            'healthy_services': healthy_services,
            'degraded_services': degraded_services,
            'overall_health': healthy_services / total_services if total_services > 0 else 0,
            'service_details': self.service_status.copy()
        }

class NeoCloneTUI:
    """Main Neo-Clone TUI Application"""
    
    def __init__(self, config: Optional[TUIConfig] = None):
        self.config = config or TUIConfig()
        self.console = Console()
        self.layout = Layout()

        # Core components
        self.skill_manager = SkillManager()
        self.event_manager = EventManager()

        # Performance & Caching
        self.cache = MultiLevelCache()
        self.resource_pool = ResourcePool(self._create_expensive_resource, max_size=10)
        self.async_io_manager = AsyncIOManager()
        self.di_container = DependencyInjector()

        # Advanced AI Features
        self.model_ensemble = ModelEnsemble()
        self.adaptive_learning = AdaptiveLearningEngine()
        self.recommendation_engine = RecommendationEngine()

        # Enterprise Features
        self.audit_logger = AuditLogger()
        self.rate_limiter = RateLimiter()
        self.session_manager = SessionManager()

        # Security & Reliability
        self.input_validator = InputValidator()
        self.circuit_breaker = CircuitBreaker()
        self.degradation_manager = GracefulDegradationManager()

        # Data
        self.chat_history: List[ChatMessage] = []
        self.current_context: Dict[str, Any] = {}
        self.file_browser_path = Path.cwd()
        self.analytics_data = defaultdict(list)

        # Advanced features
        self.performance_monitor = PerformanceMonitor()
        self.realtime_updater = RealTimeUpdater() if self.config.enable_realtime_monitoring else None
        self.suggestion_engine = SuggestionEngine() if self.config.auto_suggestions else None
        self.voice_processor = VoiceProcessor() if self.config.voice_input else None

        # UI state
        self.running = False
        self.current_panel = "chat"
        self.input_buffer = ""
        self.start_time = time.time()
        self.last_activity = time.time()
        self.system_health = {"cpu": 0, "memory": 0, "network": 0}
        self.current_session_id = None

        # Performance caches
        self._sorted_skills_cache = None
        self._cache_timestamp = 0

        # Setup dependency injection
        self._setup_dependency_injection()

        # Setup event handlers
        self._setup_event_handlers()

        # Setup graceful degradation
        self._setup_graceful_degradation()

        # Initialize layout
        self._setup_layout()

    def _create_expensive_resource(self):
        """Factory for expensive resources in pool"""
        # Placeholder for expensive resource creation
        return {"type": "expensive_resource", "created_at": time.time()}

    def _setup_dependency_injection(self):
        """Setup dependency injection container"""
        self.di_container.register(EventManager, self.event_manager, singleton=True)
        self.di_container.register(MultiLevelCache, self.cache, singleton=True)
        self.di_container.register(AuditLogger, self.audit_logger, singleton=True)
        self.di_container.register(RateLimiter, self.rate_limiter, singleton=True)

    def _setup_graceful_degradation(self):
        """Setup graceful degradation for critical services"""
        self.degradation_manager.register_service("skill_execution", self._check_skill_health)
        self.degradation_manager.register_service("model_inference", self._check_model_health)
        self.degradation_manager.register_service("file_operations", self._check_file_health)

        # Set fallbacks
        self.degradation_manager.set_fallback("skill_execution", self._skill_execution_fallback)
        self.degradation_manager.set_fallback("model_inference", self._model_inference_fallback)
        self.degradation_manager.set_fallback("file_operations", self._file_operations_fallback)

    async def _check_skill_health(self) -> bool:
        """Health check for skill execution"""
        return len(self.skill_manager.skills) > 0

    async def _check_model_health(self) -> bool:
        """Health check for model inference"""
        return len(self.model_ensemble.models) > 0

    async def _check_file_health(self) -> bool:
        """Health check for file operations"""
        try:
            Path.cwd().stat()
            return True
        except:
            return False

    async def _skill_execution_fallback(self, *args, **kwargs):
        """Fallback for skill execution"""
        return {"status": "degraded", "message": "Skill execution temporarily unavailable", "fallback_response": "I'm currently operating in degraded mode. Please try again later."}

    async def _model_inference_fallback(self, *args, **kwargs):
        """Fallback for model inference"""
        return {"status": "degraded", "response": "Model inference temporarily unavailable. Using cached responses where possible."}

    async def _file_operations_fallback(self, *args, **kwargs):
        """Fallback for file operations"""
        return {"status": "degraded", "message": "File operations temporarily unavailable", "files": []}
        
    def _setup_event_handlers(self):
        """Setup event handlers"""
        self.event_manager.subscribe('skill_executed', self._on_skill_executed)
        self.event_manager.subscribe('message_added', self._on_message_added)
        self.event_manager.subscribe('file_selected', self._on_file_selected)
    
    def _on_skill_executed(self, event):
        """Handle skill execution event"""
        data = event['data']
        self.analytics_data['skill_executions'].append({
            'skill': data['skill'],
            'function': data['function'],
            'timestamp': event['timestamp'],
            'success': data.get('success', False)
        })
    
    def _on_message_added(self, event):
        """Handle message added event"""
        self.analytics_data['message_count'] += 1
    
    def _on_file_selected(self, event):
        """Handle file selection event"""
        file_path = event['data']['path']
        self.file_browser_path = Path(file_path).parent
    
    def _setup_layout(self):
        """Setup the multi-panel layout"""
        # Create main layout structure
        self.layout.split(
            Layout(name="header", size=3),
            Layout(name="main"),
            Layout(name="footer", size=3)
        )
        
        # Split main area into panels
        self.layout["main"].split_row(
            Layout(name="left", ratio=2),
            Layout(name="right", ratio=1)
        )
        
        # Split left column
        self.layout["left"].split_column(
            Layout(name="chat", ratio=3),
            Layout(name="context", ratio=1)
        )
        
        # Split right column
        self.layout["right"].split_column(
            Layout(name="skills", ratio=1),
            Layout(name="files", ratio=1),
            Layout(name="analytics", ratio=1)
        )
        
    def _render_header(self) -> Panel:
        """Render header panel"""
        header_text = Text(" Neo-Clone Superior TUI", style="bold blue")
        header_text.append(" | ", style="dim")
        header_text.append(f"Skills: {len(self.skill_manager.skills)}", style="green")
        header_text.append(" | ", style="dim")
        header_text.append(f"Theme: {self.config.theme}", style="cyan")
        header_text.append(" | ", style="dim")
        header_text.append(datetime.now().strftime("%H:%M:%S"), style="yellow")
        
        return Panel(
            Align.center(header_text),
            box=box.ROUNDED,
            style="blue on black"
        )
    
    def _render_chat(self) -> Panel:
        """Render chat panel"""
        if not self.chat_history:
            chat_content = Text("No messages yet. Start a conversation!", style="dim italic")
        else:
            chat_lines = []
            for msg in self.chat_history[-10:]:  # Show last 10 messages
                timestamp = msg.timestamp.strftime("%H:%M")
                sender_style = {
                    "user": "green",
                    "assistant": "blue", 
                    "system": "yellow"
                }.get(msg.sender, "white")
                
                line = Text()
                line.append(f"[{timestamp}] ", style="dim")
                line.append(f"{msg.sender}: ", style=sender_style + " bold")
                line.append(msg.content[:100] + "..." if len(msg.content) > 100 else msg.content)
                
                if msg.skill_used:
                    line.append(f" ({msg.skill_used})", style="cyan")
                
                if msg.response_time:
                    line.append(f" [{msg.response_time:.2f}s]", style="dim")
                
                chat_lines.append(line)
            
            chat_content = "\n".join(str(line) for line in chat_lines)
        
        return Panel(
            chat_content,
            title=" Chat",
            title_align="left",
            box=box.ROUNDED,
            border_style="blue"
        )
    
    def _render_context(self) -> Panel:
        """Render context panel showing current working directory, active context, and recent activity"""
        context_info = []
        
        # Current working directory
        context_info.append(f" CWD: {Path.cwd()}")
        
        # Active context items
        if self.current_context:
            context_info.append("\n Active Context:")
            for key, value in list(self.current_context.items())[:5]:  # Show first 5
                context_info.append(f"   {key}: {str(value)[:30]}...")
        
        # Recent activity
        if self.chat_history:
            last_msg = self.chat_history[-1]
            context_info.append(f"\n Last: {last_msg.sender} at {last_msg.timestamp.strftime('%H:%M:%S')}")
        
        # Most used skills
        if self.skill_manager.skills:
            top_skills = sorted(self.skill_manager.skills.values(), 
                              key=lambda x: x.usage_count, reverse=True)[:3]
            if top_skills and top_skills[0].usage_count > 0:
                context_info.append(f"\n Top Skills:")
                for skill in top_skills:
                    context_info.append(f"   {skill.name} ({skill.usage_count} uses)")
        
        context_text = "\n".join(context_info)
        
        return Panel(
            context_text,
            title=" Context",
            title_align="left",
            box=box.ROUNDED,
            border_style="green"
        )
    
    def _render_skills(self) -> Panel:
        """Render skills panel"""
        skills = self._get_sorted_skills()

        if not skills:
            skills_content = Text("No skills loaded", style="dim")
        else:
            skills_table = Table(show_header=True, header_style="bold blue")
            skills_table.add_column("Skill", style="cyan")
            skills_table.add_column("Status", style="green")
            skills_table.add_column("Uses", style="yellow")
            skills_table.add_column("Description", style="white")

            for skill in skills[:8]:  # Show first 8
                status = "" if skill.loaded else ""
                desc = skill.description[:25] + "..." if len(skill.description) > 25 else skill.description
                skills_table.add_row(skill.name, status, str(skill.usage_count), desc)

            skills_content = skills_table

        return Panel(
            skills_content,
            title=" Skills",
            title_align="left",
            box=box.ROUNDED,
            border_style="yellow"
        )
    
    def _render_files(self) -> Panel:
        """Render file browser panel with enhanced error handling"""
        try:
            if not self.file_browser_path.exists():
                file_tree = Text(f"Path does not exist: {self.file_browser_path}", style="red")
            elif not self.file_browser_path.is_dir():
                file_tree = Text(f"Path is not a directory: {self.file_browser_path}", style="red")
            else:
                files = list(self.file_browser_path.iterdir())
                files.sort(key=lambda x: (x.is_file(), x.name.lower()))

                file_tree = Tree(f" {self.file_browser_path.name}")

                for item in files[:15]:  # Show first 15 items
                    try:
                        if item.is_dir():
                            file_tree.add(f" {item.name}/", style="blue")
                        else:
                            size = item.stat().st_size
                            size_str = self._format_size(size)
                            file_tree.add(f" {item.name} ({size_str})", style="green")
                    except (OSError, PermissionError) as e:
                        file_tree.add(f" {item.name} (access denied)", style="red")

                if len(files) > 15:
                    file_tree.add(f"... and {len(files) - 15} more", style="dim")

        except (OSError, PermissionError) as e:
            file_tree = Text(f"Permission denied: {e}", style="red")
        except Exception as e:
            logger.error(f"Error rendering files panel: {e}")
            file_tree = Text(f"Error: {str(e)}", style="red")

        return Panel(
            file_tree,
            title=" Files",
            title_align="left",
            box=box.ROUNDED,
            border_style="cyan"
        )
    
    def _render_analytics(self) -> Panel:
        """Render analytics panel"""
        analytics_info = []
        
        # Basic metrics
        analytics_info.append(f" Messages: {len(self.chat_history)}")
        analytics_info.append(f" Skills: {len(self.skill_manager.skills)}")
        
        # Skill executions
        skill_executions = len(self.analytics_data.get('skill_executions', []))
        analytics_info.append(f" Skill Runs: {skill_executions}")
        
        # Response time stats
        response_times = [msg.response_time for msg in self.chat_history if msg.response_time]
        if response_times:
            avg_time = sum(response_times) / len(response_times)
            analytics_info.append(f" Avg Response: {avg_time:.2f}s")
        
        # Memory usage (simplified)
        analytics_info.append(f" Memory: ~50MB")  # Placeholder
        
        # Uptime
        uptime = time.time() - self.start_time
        analytics_info.append(f" Uptime: {uptime:.0f}s")
        
        # Most active skill
        if self.skill_manager.skills:
            most_used = max(self.skill_manager.skills.values(), key=lambda x: x.usage_count)
            if most_used.usage_count > 0:
                analytics_info.append(f" Top Skill: {most_used.name}")
        
        analytics_text = "\n".join(analytics_info)
        
        return Panel(
            analytics_text,
            title=" Analytics",
            title_align="left",
            box=box.ROUNDED,
            border_style="magenta"
        )
    
    def _render_footer(self) -> Panel:
        """Render footer panel"""
        footer_text = Text()
        
        # Current mode
        footer_text.append("Mode: ", style="dim")
        footer_text.append(self.current_panel.upper(), style="bold green")
        footer_text.append(" | ", style="dim")
        
        # Available commands
        footer_text.append("Commands: ", style="dim")
        footer_text.append("[Q]uit ", style="yellow")
        footer_text.append("[C]hat ", style="cyan")
        footer_text.append("[S]kills ", style="green")
        footer_text.append("[F]iles ", style="blue")
        footer_text.append("[H]elp", style="magenta")
        
        return Panel(
            Align.center(footer_text),
            box=box.ROUNDED,
            style="dim"
        )
    
    def _format_size(self, size_bytes: int) -> str:
        """Format file size in human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size_bytes < 1024:
                return f"{size_bytes:.1f}{unit}"
            size_bytes /= 1024
        return f"{size_bytes:.1f}TB"

    def _get_sorted_skills(self) -> List[SkillInfo]:
        """Get cached sorted skills for performance"""
        current_time = time.time()
        if self._sorted_skills_cache is None or current_time - self._cache_timestamp > 5.0:
            skills = self.skill_manager.list_skills()
            self._sorted_skills_cache = sorted(skills, key=lambda x: x.usage_count, reverse=True)
            self._cache_timestamp = current_time
        return self._sorted_skills_cache
    
    def update_layout(self):
        """Update all panel content"""
        self.layout["header"].update(self._render_header())
        self.layout["chat"].update(self._render_chat())
        self.layout["context"].update(self._render_context())
        self.layout["skills"].update(self._render_skills())
        self.layout["files"].update(self._render_files())
        self.layout["analytics"].update(self._render_analytics())
        self.layout["footer"].update(self._render_footer())
    
    async def add_message(self, sender: str, content: str, skill_used: Optional[str] = None, response_time: Optional[float] = None):
        """Add a message to chat history"""
        message = ChatMessage(
            timestamp=datetime.now(),
            sender=sender,
            content=content,
            skill_used=skill_used,
            response_time=response_time
        )
        self.chat_history.append(message)
        
        # Trim history if needed
        if len(self.chat_history) > self.config.max_history:
            self.chat_history = self.chat_history[-self.config.max_history:]
        
        # Emit event
        await self.event_manager.emit('message_added', {'message': message})
    
    async def handle_input(self, user_input: str) -> Optional[str]:
        """Handle user input and return response with enhanced security and performance"""
        if not user_input.strip():
            return None

        # Create or get session
        if not self.current_session_id:
            self.current_session_id = self.session_manager.create_session("default_user")

        # Rate limiting check
        if not self.rate_limiter.is_allowed("default_user"):
            response = "Rate limit exceeded. Please wait before sending more requests."
            await self.add_message("system", response)
            await self.audit_logger.log_event("rate_limit", "default_user", "input", "chat", "blocked", {"input_length": len(user_input)})
            return response

        # Input validation
        validation = self.input_validator.validate_input(user_input)
        if not validation['valid']:
            error_msg = f"Input validation failed: {'; '.join(validation['errors'])}"
            await self.add_message("system", error_msg)
            await self.audit_logger.log_event("validation_failure", "default_user", "input", "chat", "rejected", {"errors": validation['errors']})
            return error_msg

        # Sanitize input
        sanitized_input = validation['sanitized_input']

        start_time = time.time()

        # Add user message
        await self.add_message("user", sanitized_input)

        try:
            # Circuit breaker protection
            response = await self.circuit_breaker.call(self._process_input_core, sanitized_input)

            # Calculate response time
            response_time = time.time() - start_time

            # Add assistant response
            await self.add_message("assistant", response, response_time=response_time)

            # Update session data
            self.session_manager.update_session_data(self.current_session_id, "last_input", sanitized_input)
            self.session_manager.update_session_data(self.current_session_id, "last_response", response)

            # Adaptive learning
            self.adaptive_learning.learn_from_interaction(sanitized_input, response, True, response_time)

            # Audit logging
            await self.audit_logger.log_event("input_processed", "default_user", "chat", "input", "success",
                                            {"response_time": response_time, "input_length": len(sanitized_input)})

            return response

        except CircuitBreakerOpenException:
            error_msg = "Service temporarily unavailable due to high error rate. Please try again later."
            await self.add_message("system", error_msg)
            await self.audit_logger.log_event("circuit_breaker", "default_user", "input", "chat", "blocked", {})
            return error_msg
        except Exception as e:
            error_msg = f"Error processing input: {str(e)}"
            await self.add_message("system", error_msg)
            await self.audit_logger.log_event("error", "default_user", "input", "chat", "failed", {"error": str(e)})
            return error_msg

    async def _process_input_core(self, user_input: str) -> str:
        """Core input processing logic"""
        # Check cache first
        cache_key = f"input_{hashlib.md5(user_input.encode()).hexdigest()}"
        cached_response = self.cache.get(cache_key)
        if cached_response:
            return f"[CACHED] {cached_response}"

        # Command handling
        if user_input.lower().startswith('/help'):
            response = await self._handle_help_command()
        elif user_input.lower().startswith('/skills'):
            response = await self._handle_skills_command(user_input)
        elif user_input.lower().startswith('/skill'):
            response = await self._handle_skill_command(user_input)
        elif user_input.lower().startswith('/clear'):
            self.chat_history.clear()
            response = "Chat history cleared."
        elif user_input.lower().startswith('/theme'):
            response = await self._handle_theme_command(user_input)
        elif user_input.lower().startswith('/audit'):
            response = await self._handle_audit_command(user_input)
        elif user_input.lower().startswith('/health'):
            response = await self._handle_health_command()
        else:
            # Try to process as natural language with ensemble
            response = await self._process_natural_language_enhanced(user_input)

        # Cache response
        self.cache.set(cache_key, response, ttl=300)  # 5 minute TTL

        return response
    
    async def _handle_help_command(self) -> str:
        """Handle help command"""
        help_text = """
Available commands:
 /help - Show this help message
 /skills - List available skills
 /skill <name> <function> [args] - Execute a skill
 /clear - Clear chat history
 /theme <dark|light> - Change theme

You can also ask questions naturally and I'll try to help!
        """.strip()
        return help_text
    
    async def _handle_skills_command(self, user_input: str) -> str:
        """Handle skills command"""
        skills = self.skill_manager.list_skills()
        
        if not skills:
            return "No skills available."
        
        skills_info = []
        for skill in skills:
            status = "" if skill.loaded else ""
            functions = ", ".join(skill.functions[:3]) if skill.functions else "No functions"
            if len(skill.functions) > 3:
                functions += f" (+{len(skill.functions) - 3} more)"
            
            skills_info.append(f"{status} **{skill.name}**: {skill.description}")
            skills_info.append(f"   Functions: {functions}")
            skills_info.append("")
        
        return "\n".join(skills_info)
    
    async def _handle_skill_command(self, user_input: str) -> str:
        """Handle skill execution command"""
        parts = user_input.split()
        if len(parts) < 3:
            return "Usage: /skill <skill_name> <function_name> [args...]"
        
        skill_name = parts[1]
        function_name = parts[2]
        args = parts[3:] if len(parts) > 3 else []
        
        try:
            result = await self.skill_manager.execute_skill(skill_name, function_name, *args)
            
            # Format result
            if isinstance(result, dict):
                result_str = json.dumps(result, indent=2)
            else:
                result_str = str(result)
            
            await self.add_message("system", f"Executed {skill_name}.{function_name}", skill_used=f"{skill_name}.{function_name}")
            
            return f"Result from {skill_name}.{function_name}:\n{result_str}"
            
        except Exception as e:
            return f"Error executing {skill_name}.{function_name}: {str(e)}"
    
    async def _handle_theme_command(self, user_input: str) -> str:
        """Handle theme command"""
        parts = user_input.split()
        if len(parts) < 2:
            return f"Current theme: {self.config.theme}. Usage: /theme <dark|light>"

        theme = parts[1].lower()
        if theme in ['dark', 'light']:
            self.config.theme = theme
            return f"Theme changed to {theme}"
        else:
            return "Invalid theme. Use 'dark' or 'light'."

    async def _handle_audit_command(self, user_input: str) -> str:
        """Handle audit command"""
        parts = user_input.split()
        if len(parts) < 2:
            return "Usage: /audit <user|events|summary>"

        subcommand = parts[1].lower()
        if subcommand == "summary":
            audit_trail = self.audit_logger.get_audit_trail(limit=10)
            summary = f"Recent audit events: {len(audit_trail)}\n"
            for event in audit_trail[-5:]:
                summary += f" {event['timestamp'][:19]} {event['event_type']} {event['action']}\n"
            return summary
        elif subcommand == "events":
            events = self.audit_logger.get_event_history(limit=5)
            return f"Recent events: {json.dumps(events, indent=2, default=str)}"
        else:
            return "Invalid audit subcommand. Use 'summary' or 'events'."

    async def _handle_health_command(self) -> str:
        """Handle health check command"""
        health = self.degradation_manager.get_system_health()
        circuit_state = self.circuit_breaker.get_state()
        rate_limit = self.rate_limiter.get_remaining_requests("default_user")

        health_report = f"""
System Health Report:
 Overall Health: {health['overall_health']:.1%}
 Services: {health['healthy_services']}/{health['total_services']} healthy
 Circuit Breaker: {circuit_state['state']}
 Rate Limit Remaining: {rate_limit} requests
 Cache Status: {len(self.cache.memory_cache)} items in memory
 Active Sessions: {len(self.session_manager.sessions)}
        """.strip()

        return health_report
    
    async def _process_natural_language_enhanced(self, user_input: str) -> str:
        """Process natural language input with ensemble and recommendations"""
        # Get recommendations for this input
        recommendations = self.recommendation_engine.get_recommendations("default_user", "skill", limit=3)

        # Use model ensemble for response generation
        try:
            ensemble_result = await self.model_ensemble.predict_ensemble(user_input, "general")
            response = ensemble_result.get('response', '')
        except Exception as e:
            logger.warning(f"Ensemble prediction failed: {e}")
            response = await self._fallback_nlp_processing(user_input)

        # Add recommendations if available
        if recommendations:
            response += "\n\n Recommended skills for you:\n"
            for rec in recommendations:
                response += f" {rec['item']} (confidence: {rec['score']:.2f})\n"

        # Get adaptive learning suggestions
        strategy = self.adaptive_learning.get_optimal_strategy(user_input)
        if strategy['strategy'] == 'learned':
            response += f"\n Based on your history, this type of request usually takes {strategy['avg_response_time']:.2f}s"

        return response

    async def _fallback_nlp_processing(self, user_input: str) -> str:
        """Fallback NLP processing when ensemble fails"""
        # Use graceful degradation
        return await self.degradation_manager.execute_with_degradation(
            "skill_execution",
            self._basic_skill_routing,
            user_input
        )

    async def _basic_skill_routing(self, user_input: str) -> str:
        """Basic keyword-based skill routing"""
        input_lower = user_input.lower()

        # Check for code generation requests
        if any(keyword in input_lower for keyword in ['generate code', 'write code', 'create function']):
            try:
                result = await self.skill_manager.execute_skill('code_generation', 'generate_code', user_input)
                await self.add_message("system", "Generated code using code_generation skill", skill_used="code_generation.generate_code")
                return f"I've generated some code for you:\n{result}"
            except Exception as e:
                return f"Code generation failed: {str(e)}"

        # Check for file operations
        elif any(keyword in input_lower for keyword in ['file', 'directory', 'folder']):
            try:
                result = await self.skill_manager.execute_skill('file_manager', 'handle_file_request', user_input)
                await self.add_message("system", "File operation using file_manager skill", skill_used="file_manager.handle_file_request")
                return f"File operation result:\n{result}"
            except Exception as e:
                return f"File operation failed: {str(e)}"

        # Check for web search
        elif any(keyword in input_lower for keyword in ['search', 'find information', 'look up']):
            try:
                result = await self.skill_manager.execute_skill('web_search', 'search', user_input)
                await self.add_message("system", "Web search using web_search skill", skill_used="web_search.search")
                return f"Search results:\n{result}"
            except Exception as e:
                return f"Web search failed: {str(e)}"

        # Default response with suggestions
        suggestions = self.suggestion_engine.get_suggestions(user_input) if self.suggestion_engine else []
        response = f"I understand you said: '{user_input}'. I'm still learning to handle different types of requests."

        if suggestions:
            response += "\n\nTry these suggestions:\n" + "\n".join(f" {s}" for s in suggestions[:3])

        response += "\n\nUse /skills to see what I can do!"
        return response

    # Advanced TUI Features

    def get_performance_metrics(self) -> Dict[str, Any]:
        """Get current performance metrics"""
        return self.performance_monitor.get_performance_summary()

    def get_system_health(self) -> Dict[str, Any]:
        """Get system health status"""
        # Simulate system health (in real implementation, would use psutil)
        import random
        self.system_health = {
            "cpu_percent": random.uniform(10, 90),
            "memory_percent": random.uniform(20, 80),
            "disk_usage": random.uniform(30, 70),
            "network_connections": random.randint(5, 50),
            "uptime_seconds": time.time() - self.start_time
        }
        return self.system_health

    def get_suggestions(self, partial_input: str) -> List[str]:
        """Get intelligent suggestions"""
        if self.suggestion_engine:
            context = {
                "current_panel": self.current_panel,
                "recent_commands": list(self.suggestion_engine.command_history)[-5:],
                "current_file": str(self.file_browser_path) if hasattr(self, 'file_browser_path') else None
            }
            return self.suggestion_engine.get_suggestions(partial_input, context)
        return []

    async def process_voice_input(self) -> str:
        """Process voice input"""
        if self.voice_processor:
            return await self.voice_processor.start_listening()
        return "Voice input not enabled"

    def speak_response(self, text: str):
        """Speak response using TTS"""
        if self.voice_processor:
            self.voice_processor.speak(text)

    def get_realtime_updates(self) -> List[Dict[str, Any]]:
        """Get real-time system updates"""
        updates = []

        # Performance alerts
        perf = self.get_performance_metrics()
        if perf.get('response_time_avg', 0) > 5.0:
            updates.append({
                "type": "warning",
                "message": "High response time detected",
                "timestamp": time.time()
            })

        # System health alerts
        health = self.get_system_health()
        if health.get('cpu_percent', 0) > 80:
            updates.append({
                "type": "critical",
                "message": "High CPU usage",
                "timestamp": time.time()
            })

        if health.get('memory_percent', 0) > 85:
            updates.append({
                "type": "critical",
                "message": "High memory usage",
                "timestamp": time.time()
            })

        return updates

    def create_enhanced_layout(self) -> Layout:
        """Create enhanced multi-panel layout"""
        layout = Layout()

        # Split into main areas
        layout.split(
            Layout(name="header", size=3),
            Layout(name="main", ratio=1),
            Layout(name="footer", size=2)
        )

        # Split main area
        layout["main"].split_row(
            Layout(name="sidebar", ratio=1),
            Layout(name="content", ratio=3),
            Layout(name="info_panel", ratio=1)
        )

        # Split content area
        layout["content"].split(
            Layout(name="chat_area", ratio=4),
            Layout(name="input_area", size=3)
        )

        return layout

    def render_performance_panel(self) -> Panel:
        """Render performance metrics panel"""
        perf_data = self.get_performance_metrics()

        table = Table(title="Performance Metrics")
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="magenta")
        table.add_column("Status", style="green")

        for key, value in perf_data.items():
            if isinstance(value, (int, float)):
                status = "" if value < 100 else ""
                table.add_row(key, f"{value:.2f}", status)
            else:
                table.add_row(key, str(value), "-")

        return Panel(table, title="System Performance")

    def render_health_panel(self) -> Panel:
        """Render system health panel"""
        health_data = self.get_system_health()

        health_table = Table(title="System Health")
        health_table.add_column("Component", style="cyan")
        health_table.add_column("Usage", style="yellow")
        health_table.add_column("Status", style="green")

        for component, usage in health_data.items():
            if isinstance(usage, (int, float)) and usage <= 100:
                if usage < 50:
                    status = ""
                    color = "green"
                elif usage < 80:
                    status = ""
                    color = "yellow"
                else:
                    status = ""
                    color = "red"
                health_table.add_row(component, f"{usage:.1f}%", f"[{color}]{status}[/{color}]")
            else:
                health_table.add_row(component, str(usage), "-")

        return Panel(health_table, title="System Health")

    def render_suggestions_panel(self, current_input: str = "") -> Panel:
        """Render suggestions panel"""
        suggestions = self.get_suggestions(current_input)

        if not suggestions:
            return Panel("No suggestions available", title="Suggestions")

        suggestion_text = "\n".join(f" {suggestion}" for suggestion in suggestions)
        return Panel(suggestion_text, title="Smart Suggestions")

    def render_realtime_updates(self) -> Panel:
        """Render real-time updates panel"""
        updates = self.get_realtime_updates()

        if not updates:
            return Panel("No active alerts", title="Real-time Updates")

        update_lines = []
        for update in updates[-5:]:  # Show last 5 updates
            timestamp = datetime.fromtimestamp(update['timestamp']).strftime("%H:%M:%S")
            icon = "" if update['type'] == 'warning' else ""
            update_lines.append(f"{icon} {timestamp}: {update['message']}")

        return Panel("\n".join(update_lines), title="Real-time Updates")

    async def run(self):
        """Enhanced main TUI loop with comprehensive features"""
        self.running = True
        self.start_time = time.time()

        # Start enterprise services
        await self.audit_logger.start()

        # Initialize advanced features
        if self.realtime_updater:
            await self.realtime_updater.start()

        # Add welcome message with enhanced features
        welcome_msg = " Welcome to Neo-Clone Superior TUI v3.0 - Enterprise Edition!\n"
        welcome_msg += " Advanced Features: Multi-level caching, Model ensemble, Adaptive learning, Audit logging\n"
        welcome_msg += " Security: Input validation, Rate limiting, Circuit breaker, Graceful degradation\n"
        welcome_msg += " Commands: /help, /skills, /audit, /health - or start chatting!"
        await self.add_message("system", welcome_msg)

        # Start background tasks
        event_task = asyncio.create_task(self.event_manager.process_events())
        monitor_task = asyncio.create_task(self._monitor_system()) if self.config.enable_realtime_monitoring else None
        cleanup_task = asyncio.create_task(self._background_cleanup())

        # Setup enhanced layout
        self.layout = self.create_enhanced_layout()

        try:
            with Live(self.layout, refresh_per_second=10, screen=True) as live:
                while self.running:
                    # Update layout with real-time data
                    self.update_enhanced_layout()

                    # Performance monitoring
                    if self.performance_monitor:
                        self.performance_monitor.record_metric("ui_refresh", time.time() - self.last_activity)

                    # Auto-suggestions for idle users
                    if self.suggestion_engine and time.time() - self.last_activity > 30:
                        popular = self.suggestion_engine.get_popular_commands(3)
                        if popular:
                            await self.realtime_updater.publish("suggestion", {
                                "type": "popular_commands",
                                "commands": [cmd for cmd, _ in popular]
                            })

                    # Demo interaction with enhanced features
                    if len(self.chat_history) == 1 and time.time() - self.start_time > 3:
                        features = []
                        if self.cache:
                            features.append("multi-level caching")
                        if self.model_ensemble.models:
                            features.append("model ensemble")
                        if self.adaptive_learning:
                            features.append("adaptive learning")
                        if self.audit_logger:
                            features.append("audit logging")

                        feature_list = ", ".join(features) if features else "enterprise AI capabilities"
                        await self.add_message("assistant", f" Enterprise mode activated with {feature_list}! Security, performance, and reliability enhanced. Try /health to see system status!")

                    await asyncio.sleep(0.1)

        except KeyboardInterrupt:
            self.console.print("\n Goodbye! Thanks for using Neo-Clone Enterprise!", style="bold green")
        finally:
            self.running = False
            self.event_manager.running = False

            # Cleanup tasks
            event_task.cancel()
            if monitor_task:
                monitor_task.cancel()
            cleanup_task.cancel()

            if self.realtime_updater:
                await self.realtime_updater.stop()

            await self.audit_logger.stop()

            # Final audit log
            await self.audit_logger.log_event("shutdown", "system", "shutdown", "application", "success", {})

    async def _background_cleanup(self):
        """Background cleanup tasks"""
        while self.running:
            try:
                # Cleanup expired sessions
                self.session_manager.cleanup_expired_sessions()

                # Cleanup old cache files
                self.cache._cleanup_disk_cache()

                # Log system health periodically
                if int(time.time()) % 300 == 0:  # Every 5 minutes
                    health = self.degradation_manager.get_system_health()
                    await self.audit_logger.log_event("health_check", "system", "monitor", "health", "info",
                                                    {"overall_health": health['overall_health']})

                await asyncio.sleep(60)  # Run every minute

            except Exception as e:
                logger.error(f"Background cleanup error: {e}")
                await asyncio.sleep(60)

    async def _monitor_system(self):
        """Background system monitoring"""
        while self.running:
            try:
                # Record system metrics
                health = self.get_system_health()
                for key, value in health.items():
                    if isinstance(value, (int, float)):
                        self.performance_monitor.record_metric(f"system_{key}", value)

                # Check for alerts
                updates = self.get_realtime_updates()
                for update in updates:
                    await self.realtime_updater.publish("alert", update)

                await asyncio.sleep(5)  # Monitor every 5 seconds

            except Exception as e:
                logger.error(f"Monitoring error: {e}")
                await asyncio.sleep(10)

    def update_enhanced_layout(self):
        """Update the enhanced layout with real-time data"""
        try:
            # Update main panels
            self.layout["header"].update(self._render_header())
            self.layout["sidebar"].update(self._render_sidebar())
            self.layout["content"].update(self._render_content())
            self.layout["info_panel"].update(self._render_info_panel())
            self.layout["footer"].update(self._render_footer())

        except Exception as e:
            logger.error(f"Layout update error: {e}")

    def _render_header(self) -> Panel:
        """Render enhanced header with system status"""
        health = self.get_system_health()
        uptime = time.time() - self.start_time

        status_parts = []
        if health.get('cpu_percent', 0) < 80:
            status_parts.append("[green] CPU[/green]")
        else:
            status_parts.append("[red] CPU[/red]")

        if health.get('memory_percent', 0) < 85:
            status_parts.append("[green] Memory[/green]")
        else:
            status_parts.append("[red] Memory[/red]")

        status_line = " | ".join(status_parts)

        header_text = f"""
Neo-Clone Superior TUI v2.0
{status_line}
Uptime: {uptime:.0f}s | Skills: {len(self.skill_manager.skills)} | Messages: {len(self.chat_history)}
        """.strip()

        return Panel(header_text, title=" Neo-Clone AI Assistant", border_style="blue")

    def _render_sidebar(self) -> Panel:
        """Render sidebar with skills and suggestions"""
        content = []

        # Skills section
        content.append("[bold cyan]Available Skills:[/bold cyan]")
        skills = self.skill_manager.list_skills()[:10]  # Show first 10
        for skill in skills:
            status = "[green][/green]" if skill.loaded else "[red][/red]"
            content.append(f"{status} {skill.name}")

        if len(self.skill_manager.skills) > 10:
            content.append(f"... and {len(self.skill_manager.skills) - 10} more")

        content.append("")

        # Suggestions section
        if self.suggestion_engine:
            content.append("[bold yellow]Smart Suggestions:[/bold yellow]")
            popular = self.suggestion_engine.get_popular_commands(3)
            for cmd, count in popular:
                content.append(f" {cmd} ({count} uses)")

        return Panel("\n".join(content), title=" Skills & Suggestions")

    def _render_content(self) -> Panel:
        """Render main content area"""
        if not self.chat_history:
            return Panel("No messages yet. Start a conversation!", title="Chat")

        # Show last 20 messages
        recent_messages = self.chat_history[-20:]

        content_lines = []
        for msg in recent_messages:
            timestamp = datetime.fromtimestamp(msg.timestamp).strftime("%H:%M:%S")
            role_icon = {"user": "", "assistant": "", "system": ""}.get(msg.role, "")
            content_lines.append(f"[{timestamp}] {role_icon} {msg.content}")

        return Panel("\n".join(content_lines), title=" Conversation")

    def _render_info_panel(self) -> Panel:
        """Render info panel with performance and health"""
        perf = self.render_performance_panel()
        health = self.render_health_panel()
        updates = self.render_realtime_updates()

        return Panel(f"{perf}\n\n{health}\n\n{updates}", title=" System Info")

    def _render_footer(self) -> Panel:
        """Render footer with input hints"""
        hints = [
            " Type /help for commands",
            " Voice input: /voice" if self.config.voice_input else "",
            " Real-time monitoring active" if self.config.enable_realtime_monitoring else "",
            " AI suggestions enabled" if self.config.auto_suggestions else ""
        ]

        hints = [h for h in hints if h]  # Remove empty hints
        footer_text = " | ".join(hints) if hints else "Ready for input..."

        return Panel(footer_text, title=" Status")

def main():
    """Main entry point with enhanced initialization"""
    config = TUIConfig()
    tui = NeoCloneTUI(config)

    # Initialize model ensemble with available models
    try:
        # Add placeholder models - in real implementation, these would be actual model instances
        tui.model_ensemble.add_model("primary", {"name": "primary_model"}, weight=1.0)
        tui.model_ensemble.add_model("backup", {"name": "backup_model"}, weight=0.8)
        logger.info("Model ensemble initialized with 2 models")
    except Exception as e:
        logger.warning(f"Failed to initialize model ensemble: {e}")

    # Initialize recommendation engine with some sample data
    try:
        tui.recommendation_engine.add_user_interaction("default_user", "code_generation", 0.9)
        tui.recommendation_engine.add_user_interaction("default_user", "text_analysis", 0.8)
        logger.info("Recommendation engine initialized")
    except Exception as e:
        logger.warning(f"Failed to initialize recommendation engine: {e}")

    try:
        asyncio.run(tui.run())
    except KeyboardInterrupt:
        print("\n Goodbye!")
    except Exception as e:
        logger.error(f"Application error: {e}")
        print(f"\n Application error: {e}")

if __name__ == "__main__":
    main()