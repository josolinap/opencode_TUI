from functools import lru_cache
'\nSkill Auto-Discovery and Dynamic Loading System\n\nAdvanced system for automatically discovering, validating, and loading skills\nwith hot-reloading capabilities and dependency management.\n'
import json
import time
import logging
import threading
import importlib
import inspect
import hashlib
from typing import Dict, List, Optional, Any, Type, Callable, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import sys
import os
import ast
import pkgutil
logger = logging.getLogger(__name__)

class SkillStatus(Enum):
    """Skill status states"""
    DISCOVERED = 'discovered'
    LOADING = 'loading'
    LOADED = 'loaded'
    ERROR = 'error'
    DISABLED = 'disabled'
    OUTDATED = 'outdated'

class SkillType(Enum):
    """Types of skills"""
    GENERATIVE = 'generative'
    ANALYTICAL = 'analytical'
    SYSTEM = 'system'
    UTILITY = 'utility'
    INTEGRATION = 'integration'

@dataclass
class SkillMetadata:
    """Metadata for a skill"""
    name: str
    description: str
    version: str
    author: str
    skill_type: SkillType
    category: str
    tags: List[str]
    dependencies: List[str]
    required_models: List[str]
    parameters: Dict[str, Any]
    example_usage: str
    file_path: str
    class_name: str
    file_hash: str
    last_modified: float
    status: SkillStatus
    error_message: Optional[str] = None
    load_time: Optional[float] = None
    performance_metrics: Dict[str, float] = None

    @lru_cache(maxsize=128)
    def __post_init__(self):
        if self.performance_metrics is None:
            self.performance_metrics = {}
        if self.tags is None:
            self.tags = []
        if self.dependencies is None:
            self.dependencies = []
        if self.required_models is None:
            self.required_models = []
        if self.parameters is None:
            self.parameters = {}

class SkillValidator:
    """Validates skill implementations"""

    def __init__(self):
        self.validation_rules = {'required_methods': ['execute'], 'required_attributes': ['name', 'description'], 'forbidden_imports': ['os.system', 'subprocess.call', 'eval', 'exec'], 'max_file_size': 1024 * 1024, 'required_docstrings': True}

    def validate_skill_file(self, file_path: Path) -> Tuple[bool, List[str]]:
        """Validate a skill file"""
        errors = []
        if file_path.stat().st_size > self.validation_rules['max_file_size']:
            errors.append(f'File too large: {file_path.stat().st_size} bytes')
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            tree = ast.parse(content)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        if any((forbidden in alias.name for forbidden in self.validation_rules['forbidden_imports'])):
                            errors.append(f'Forbidden import: {alias.name}')
                elif isinstance(node, ast.ImportFrom):
                    if node.module and any((forbidden in node.module for forbidden in self.validation_rules['forbidden_imports'])):
                        errors.append(f'Forbidden import from: {node.module}')
            if self.validation_rules['required_docstrings']:
                if not ast.get_docstring(tree):
                    errors.append('Missing module docstring')
            skill_classes = []
            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    methods = [n.name for n in node.body if isinstance(n, ast.FunctionDef)]
                    if any((method in methods for method in self.validation_rules['required_methods'])):
                        skill_classes.append(node.name)
            if not skill_classes:
                errors.append('No valid skill classes found')
        except SyntaxError as e:
            errors.append(f'Syntax error: {e}')
        except Exception as e:
            errors.append(f'Parse error: {e}')
        return (len(errors) == 0, errors)

    def validate_skill_class(self, skill_class: Type) -> Tuple[bool, List[str]]:
        """Validate a skill class"""
        errors = []
        for method in self.validation_rules['required_methods']:
            if not hasattr(skill_class, method):
                errors.append(f'Missing required method: {method}')
            else:
                method_obj = getattr(skill_class, method)
                if not callable(method_obj):
                    errors.append(f'Method {method} is not callable')
                else:
                    sig = inspect.signature(method_obj)
                    if 'params' not in sig.parameters:
                        errors.append(f"Method {method} missing 'params' parameter")
        for attr in self.validation_rules['required_attributes']:
            if not hasattr(skill_class, attr):
                errors.append(f'Missing required attribute: {attr}')
        return (len(errors) == 0, errors)

class SkillLoader:
    """Loads and manages skill instances"""

    def __init__(self, skills_dir: str='skills'):
        self.skills_dir = Path(skills_dir)
        self.loaded_skills: Dict[str, Any] = {}
        self.skill_modules: Dict[str, Any] = {}
        self._lock = threading.RLock()

    def load_skill(self, metadata: SkillMetadata) -> Tuple[bool, Any, str]:
        """Load a skill from metadata"""
        with self._lock:
            try:
                if str(self.skills_dir.parent) not in sys.path:
                    sys.path.insert(0, str(self.skills_dir.parent))
                module_name = self.skills_dir.stem + '.' + Path(metadata.file_path).stem
                if module_name in self.skill_modules:
                    module = importlib.reload(self.skill_modules[module_name])
                else:
                    module = importlib.import_module(module_name)
                    self.skill_modules[module_name] = module
                skill_class = getattr(module, metadata.class_name)
                skill_instance = skill_class()
                self.loaded_skills[metadata.name] = skill_instance
                return (True, skill_instance, 'Skill loaded successfully')
            except Exception as e:
                error_msg = f'Failed to load skill {metadata.name}: {e}'
                logger.error(error_msg)
                return (False, None, error_msg)

    def unload_skill(self, skill_name: str) -> bool:
        """Unload a skill"""
        with self._lock:
            if skill_name in self.loaded_skills:
                del self.loaded_skills[skill_name]
                return True
            return False

    def reload_skill(self, metadata: SkillMetadata) -> Tuple[bool, Any, str]:
        """Reload a skill"""
        self.unload_skill(metadata.name)
        return self.load_skill(metadata)

    def get_skill(self, skill_name: str) -> Optional[Any]:
        """Get a loaded skill instance"""
        with self._lock:
            return self.loaded_skills.get(skill_name)

    def list_loaded_skills(self) -> List[str]:
        """List all loaded skill names"""
        with self._lock:
            return list(self.loaded_skills.keys())

class SkillAutoDiscovery:
    """Main auto-discovery system"""

    def __init__(self, skills_dir: str='skills', config_path: str='skill_discovery_config.json'):
        self.skills_dir = Path(skills_dir)
        self.config_path = Path(config_path)
        self.discovered_skills: Dict[str, SkillMetadata] = {}
        self.validator = SkillValidator()
        self.loader = SkillLoader(skills_dir)
        self.auto_reload_enabled = True
        self.auto_load_enabled = True
        self._lock = threading.RLock()
        self._watch_thread = None
        self._watching = False
        self._load_config()
        self.discover_skills()
        if self.auto_reload_enabled:
            self._start_file_watching()

    def _load_config(self):
        """Load discovery configuration"""
        try:
            if self.config_path.exists():
                with open(self.config_path, 'r') as f:
                    config = json.load(f)
                    self.auto_reload_enabled = config.get('auto_reload_enabled', True)
                    self.auto_load_enabled = config.get('auto_load_enabled', True)
                logger.info('Skill discovery configuration loaded')
        except Exception as e:
            logger.warning(f'Could not load skill discovery config: {e}')

    def _save_config(self):
        """Save discovery configuration"""
        try:
            config = {'auto_reload_enabled': self.auto_reload_enabled, 'auto_load_enabled': self.auto_load_enabled, 'discovered_skills_count': len(self.discovered_skills)}
            with open(self.config_path, 'w') as f:
                json.dump(config, f, indent=2, default=str)
        except Exception as e:
            logger.warning(f'Could not save skill discovery config: {e}')

    def _calculate_file_hash(self, file_path: Path) -> str:
        """Calculate hash of file content"""
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
            return hashlib.md5(content).hexdigest()
        except Exception:
            return ''

    def _extract_metadata_from_file(self, file_path: Path) -> Optional[SkillMetadata]:
        """Extract metadata from a skill file"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            tree = ast.parse(content)
            skill_class = None
            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    methods = [n.name for n in node.body if isinstance(n, ast.FunctionDef)]
                    if 'execute' in methods:
                        skill_class = node
                        break
            if not skill_class:
                return None
            class_name = skill_class.name
            docstring = ast.get_docstring(skill_class) or ''
            metadata = {'name': class_name.lower().replace('skill', ''), 'description': docstring.split('\n')[0] if docstring else class_name, 'version': '1.0.0', 'author': 'Unknown', 'skill_type': SkillType.UTILITY, 'category': 'general', 'tags': [], 'dependencies': [], 'required_models': [], 'parameters': {}, 'example_usage': ''}
            for node in skill_class.body:
                if isinstance(node, ast.Assign):
                    for target in node.targets:
                        if isinstance(target, ast.Name):
                            attr_name = target.id
                            if hasattr(ast, 'Constant') and isinstance(node.value, ast.Constant):
                                attr_value = node.value.value
                            elif hasattr(ast, 'Str') and isinstance(node.value, ast.Str):
                                attr_value = node.value.s
                            else:
                                continue
                            if attr_name in ['name', 'description', 'version', 'author', 'category']:
                                metadata[attr_name] = attr_value
                            elif attr_name == 'tags':
                                if isinstance(attr_value, str):
                                    metadata['tags'] = [tag.strip() for tag in attr_value.split(',')]
                            elif attr_name == 'dependencies':
                                if isinstance(attr_value, str):
                                    metadata['dependencies'] = [dep.strip() for dep in attr_value.split(',')]
                            elif attr_name == 'required_models':
                                if isinstance(attr_value, str):
                                    metadata['required_models'] = [model.strip() for model in attr_value.split(',')]
            name_lower = metadata['name'].lower()
            if any((keyword in name_lower for keyword in ['generate', 'create', 'write'])):
                metadata['skill_type'] = SkillType.GENERATIVE
            elif any((keyword in name_lower for keyword in ['analyze', 'process', 'inspect'])):
                metadata['skill_type'] = SkillType.ANALYTICAL
            elif any((keyword in name_lower for keyword in ['system', 'monitor', 'manage'])):
                metadata['skill_type'] = SkillType.SYSTEM
            elif any((keyword in name_lower for keyword in ['integrate', 'connect', 'api'])):
                metadata['skill_type'] = SkillType.INTEGRATION
            return SkillMetadata(name=metadata['name'], description=metadata['description'], version=metadata['version'], author=metadata['author'], skill_type=metadata['skill_type'], category=metadata['category'], tags=metadata['tags'], dependencies=metadata['dependencies'], required_models=metadata['required_models'], parameters=metadata['parameters'], example_usage=metadata['example_usage'], file_path=str(file_path.relative_to(self.skills_dir.parent)), class_name=class_name, file_hash=self._calculate_file_hash(file_path), last_modified=file_path.stat().st_mtime, status=SkillStatus.DISCOVERED)
        except Exception as e:
            logger.error(f'Error extracting metadata from {file_path}: {e}')
            return None

    def discover_skills(self) -> Dict[str, SkillMetadata]:
        """Discover all skills in the skills directory"""
        with self._lock:
            discovered = {}
            for file_path in self.skills_dir.rglob('*.py'):
                if file_path.name.startswith('_') or file_path.name.startswith('test'):
                    continue
                (is_valid, errors) = self.validator.validate_skill_file(file_path)
                if not is_valid:
                    logger.warning(f'Skipping invalid skill file {file_path}: {errors}')
                    continue
                metadata = self._extract_metadata_from_file(file_path)
                if metadata:
                    discovered[metadata.name] = metadata
                    if metadata.name in self.discovered_skills:
                        existing = self.discovered_skills[metadata.name]
                        if existing.file_hash != metadata.file_hash:
                            metadata.status = SkillStatus.OUTDATED
                            logger.info(f'Skill {metadata.name} has been updated')
                    else:
                        logger.info(f'Discovered new skill: {metadata.name}')
            to_remove = []
            for (name, metadata) in self.discovered_skills.items():
                if not Path(metadata.file_path).exists():
                    to_remove.append(name)
                    logger.info(f'Skill {name} no longer exists')
            for name in to_remove:
                del self.discovered_skills[name]
                self.loader.unload_skill(name)
            self.discovered_skills.update(discovered)
            if self.auto_load_enabled:
                for (name, metadata) in discovered.items():
                    if metadata.status == SkillStatus.DISCOVERED:
                        self.load_skill(name)
            self._save_config()
            return self.discovered_skills

    def load_skill(self, skill_name: str) -> Tuple[bool, str]:
        """Load a specific skill"""
        with self._lock:
            if skill_name not in self.discovered_skills:
                return (False, f'Skill {skill_name} not found')
            metadata = self.discovered_skills[skill_name]
            for dep in metadata.dependencies:
                if dep not in self.discovered_skills or self.discovered_skills[dep].status != SkillStatus.LOADED:
                    return (False, f'Dependency {dep} not available')
            metadata.status = SkillStatus.LOADING
            start_time = time.time()
            (success, skill_instance, message) = self.loader.load_skill(metadata)
            load_time = time.time() - start_time
            metadata.load_time = load_time
            if success:
                metadata.status = SkillStatus.LOADED
                metadata.error_message = None
                logger.info(f'Successfully loaded skill {skill_name} in {load_time:.2f}s')
                return (True, f'Skill {skill_name} loaded successfully')
            else:
                metadata.status = SkillStatus.ERROR
                metadata.error_message = message
                logger.error(f'Failed to load skill {skill_name}: {message}')
                return (False, message)

    def unload_skill(self, skill_name: str) -> Tuple[bool, str]:
        """Unload a specific skill"""
        with self._lock:
            if skill_name not in self.discovered_skills:
                return (False, f'Skill {skill_name} not found')
            dependents = []
            for (name, metadata) in self.discovered_skills.items():
                if skill_name in metadata.dependencies and metadata.status == SkillStatus.LOADED:
                    dependents.append(name)
            if dependents:
                return (False, f'Cannot unload {skill_name}: required by {dependents}')
            success = self.loader.unload_skill(skill_name)
            if success:
                self.discovered_skills[skill_name].status = SkillStatus.DISCOVERED
                logger.info(f'Unloaded skill {skill_name}')
                return (True, f'Skill {skill_name} unloaded successfully')
            else:
                return (False, f'Failed to unload skill {skill_name}')

    def reload_skill(self, skill_name: str) -> Tuple[bool, str]:
        """Reload a specific skill"""
        with self._lock:
            if skill_name not in self.discovered_skills:
                return (False, f'Skill {skill_name} not found')
            metadata = self.discovered_skills[skill_name]
            file_path = Path(metadata.file_path)
            new_metadata = self._extract_metadata_from_file(file_path)
            if not new_metadata:
                return (False, f'Could not re-discover skill {skill_name}')
            new_metadata.status = SkillStatus.LOADING
            self.discovered_skills[skill_name] = new_metadata
            start_time = time.time()
            (success, skill_instance, message) = self.loader.reload_skill(new_metadata)
            load_time = time.time() - start_time
            new_metadata.load_time = load_time
            if success:
                new_metadata.status = SkillStatus.LOADED
                new_metadata.error_message = None
                logger.info(f'Successfully reloaded skill {skill_name} in {load_time:.2f}s')
                return (True, f'Skill {skill_name} reloaded successfully')
            else:
                new_metadata.status = SkillStatus.ERROR
                new_metadata.error_message = message
                logger.error(f'Failed to reload skill {skill_name}: {message}')
                return (False, message)

    def _start_file_watching(self):
        """Start file watching for auto-reload"""
        if self._watching:
            return
        self._watching = True
        self._watch_thread = threading.Thread(target=self._watch_loop, daemon=True)
        self._watch_thread.start()
        logger.info('Started file watching for skill auto-reload')

    def _watch_loop(self):
        """File watching loop"""
        last_hashes = {}
        while self._watching:
            try:
                for (name, metadata) in self.discovered_skills.items():
                    file_path = Path(metadata.file_path)
                    if file_path.exists():
                        current_hash = self._calculate_file_hash(file_path)
                        if name in last_hashes:
                            if last_hashes[name] != current_hash:
                                logger.info(f'Detected changes in skill {name}')
                                if metadata.status == SkillStatus.LOADED:
                                    self.reload_skill(name)
                                else:
                                    metadata.status = SkillStatus.OUTDATED
                        last_hashes[name] = current_hash
                time.sleep(10)
            except Exception as e:
                logger.error(f'Error in file watching loop: {e}')
                time.sleep(30)

    def stop_file_watching(self):
        """Stop file watching"""
        self._watching = False
        if self._watch_thread:
            self._watch_thread.join(timeout=5)
        logger.info('Stopped file watching')

    def get_skill_info(self, skill_name: str) -> Optional[Dict[str, Any]]:
        """Get detailed information about a skill"""
        with self._lock:
            if skill_name not in self.discovered_skills:
                return None
            metadata = self.discovered_skills[skill_name]
            skill_instance = self.loader.get_skill(skill_name)
            info = asdict(metadata)
            info['loaded'] = skill_instance is not None
            if skill_instance:
                info['instance_methods'] = [method for method in dir(skill_instance) if not method.startswith('_') and callable(getattr(skill_instance, method))]
                info['instance_attributes'] = [attr for attr in dir(skill_instance) if not attr.startswith('_') and (not callable(getattr(skill_instance, attr)))]
            return info

    def list_skills(self, status_filter: Optional[SkillStatus]=None) -> List[Dict[str, Any]]:
        """List all discovered skills"""
        with self._lock:
            skills = []
            for (name, metadata) in self.discovered_skills.items():
                if status_filter is None or metadata.status == status_filter:
                    skill_info = {'name': metadata.name, 'description': metadata.description, 'version': metadata.version, 'skill_type': metadata.skill_type.value, 'category': metadata.category, 'status': metadata.status.value, 'loaded': self.loader.get_skill(name) is not None, 'last_modified': metadata.last_modified, 'load_time': metadata.load_time}
                    skills.append(skill_info)
            return sorted(skills, key=lambda x: x['name'])

    def get_skills_by_type(self, skill_type: SkillType) -> List[str]:
        """Get skills by type"""
        with self._lock:
            return [name for (name, metadata) in self.discovered_skills.items() if metadata.skill_type == skill_type]

    def get_skills_by_category(self, category: str) -> List[str]:
        """Get skills by category"""
        with self._lock:
            return [name for (name, metadata) in self.discovered_skills.items() if metadata.category == category]

    def search_skills(self, query: str) -> List[Dict[str, Any]]:
        """Search skills by name, description, or tags"""
        with self._lock:
            query_lower = query.lower()
            results = []
            for (name, metadata) in self.discovered_skills.items():
                if query_lower in metadata.name.lower() or query_lower in metadata.description.lower() or any((query_lower in tag.lower() for tag in metadata.tags)):
                    skill_info = {'name': metadata.name, 'description': metadata.description, 'version': metadata.version, 'skill_type': metadata.skill_type.value, 'category': metadata.category, 'status': metadata.status.value, 'loaded': self.loader.get_skill(name) is not None}
                    results.append(skill_info)
            return results

    def get_discovery_stats(self) -> Dict[str, Any]:
        """Get discovery statistics"""
        with self._lock:
            stats = {'total_discovered': len(self.discovered_skills), 'loaded_skills': len(self.loader.list_loaded_skills()), 'skills_by_status': {}, 'skills_by_type': {}, 'skills_by_category': {}, 'auto_reload_enabled': self.auto_reload_enabled, 'auto_load_enabled': self.auto_load_enabled}
            for metadata in self.discovered_skills.values():
                status = metadata.status.value
                stats['skills_by_status'][status] = stats['skills_by_status'].get(status, 0) + 1
            for metadata in self.discovered_skills.values():
                skill_type = metadata.skill_type.value
                stats['skills_by_type'][skill_type] = stats['skills_by_type'].get(skill_type, 0) + 1
            for metadata in self.discovered_skills.values():
                category = metadata.category
                stats['skills_by_category'][category] = stats['skills_by_category'].get(category, 0) + 1
            return stats

    def enable_auto_reload(self):
        """Enable auto-reload"""
        self.auto_reload_enabled = True
        if not self._watching:
            self._start_file_watching()
        logger.info('Auto-reload enabled')

    def disable_auto_reload(self):
        """Disable auto-reload"""
        self.auto_reload_enabled = False
        self.stop_file_watching()
        logger.info('Auto-reload disabled')

    def enable_auto_load(self):
        """Enable auto-load"""
        self.auto_load_enabled = True
        logger.info('Auto-load enabled')

    def disable_auto_load(self):
        """Disable auto-load"""
        self.auto_load_enabled = False
        logger.info('Auto-load disabled')
_skill_discovery = None

def get_skill_discovery() -> SkillAutoDiscovery:
    """Get the global skill discovery instance"""
    global _skill_discovery
    if _skill_discovery is None:
        _skill_discovery = SkillAutoDiscovery()
    return _skill_discovery