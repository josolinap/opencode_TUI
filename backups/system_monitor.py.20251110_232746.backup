from functools import lru_cache
'\nsystem_monitor.py - Real-time System Monitoring and Health Checks\n\nProvides:\n- Continuous system health monitoring\n- Performance metrics collection\n- Resource usage tracking\n- Automated health checks and alerts\n- Predictive maintenance suggestions\n- System optimization recommendations\n'
import time
import threading
import asyncio
from typing import Dict, Any, List, Optional, Callable
from datetime import datetime, timedelta
from collections import deque
import logging
import platform
import os
from skills import BaseSkill
try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

    class MockPsutil:

        @staticmethod
        def cpu_percent(interval=None):
            return 45.5

        @staticmethod
        def cpu_count():
            return 4

        @staticmethod
        def cpu_freq():

            class Freq:
                current = 2500
            return Freq()

        @staticmethod
        def virtual_memory():

            class Memory:
                percent = 65.2
                used = 8 * 1024 ** 3
                available = 4 * 1024 ** 3
                total = 12 * 1024 ** 3
            return Memory()

        @staticmethod
        def disk_usage(path):

            class Disk:
                percent = 55.8
                used = 100 * 1024 ** 3
                free = 80 * 1024 ** 3
                total = 180 * 1024 ** 3
            return Disk()

        @staticmethod
        def net_io_counters():

            class Net:
                bytes_sent = 1024 ** 3
                bytes_recv = 2 * 1024 ** 3
            return Net()

        @staticmethod
        def pids():
            return list(range(100, 200))

        @staticmethod
        def getloadavg():
            return (1.5, 1.2, 0.8)
    psutil = MockPsutil()
logger = logging.getLogger(__name__)

class SystemMonitor(BaseSkill):
    """Real-time system monitoring and health check system"""

    def __init__(self):
        self.monitoring_active = False
        self.monitoring_thread = None
        self.metrics_history = deque(maxlen=10000)
        self.alerts = deque(maxlen=1000)
        self.health_checks = []
        self.alert_callbacks = []
        self.monitoring_interval = 5
        self.alert_thresholds = {'cpu_percent': 80, 'memory_percent': 85, 'disk_percent': 90, 'network_errors': 10}
        self._setup_health_checks()

    @property
    def name(self) -> str:
        return 'system_monitor'

    @property
    def description(self) -> str:
        return 'Real-time system monitoring with health checks, performance tracking, and automated alerts'

    @property
    def example_usage(self) -> str:
        return 'Start system monitoring or check current system health'

    @lru_cache(maxsize=128)
    def execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
        action = params.get('action', 'status')
        if action == 'start':
            return self.start_monitoring()
        elif action == 'stop':
            return self.stop_monitoring()
        elif action == 'status':
            return self.get_monitoring_status()
        elif action == 'health':
            return self.run_health_check()
        elif action == 'metrics':
            return self.get_recent_metrics(params.get('minutes', 5))
        elif action == 'alerts':
            return self.get_recent_alerts(params.get('limit', 10))
        elif action == 'optimize':
            return self.get_optimization_suggestions()
        else:
            return {'error': f'Unknown action: {action}'}

    def start_monitoring(self) -> Dict[str, Any]:
        """Start real-time system monitoring"""
        if self.monitoring_active:
            return {'status': 'already_running', 'message': 'System monitoring is already active'}
        try:
            self.monitoring_active = True
            self.monitoring_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
            self.monitoring_thread.start()
            return {'status': 'started', 'message': 'System monitoring started successfully', 'monitoring_interval': self.monitoring_interval, 'alert_thresholds': self.alert_thresholds}
        except Exception as e:
            self.monitoring_active = False
            return {'status': 'error', 'message': f'Failed to start monitoring: {str(e)}'}

    def stop_monitoring(self) -> Dict[str, Any]:
        """Stop system monitoring"""
        if not self.monitoring_active:
            return {'status': 'not_running', 'message': 'System monitoring is not active'}
        self.monitoring_active = False
        if self.monitoring_thread:
            self.monitoring_thread.join(timeout=5)
        return {'status': 'stopped', 'message': 'System monitoring stopped'}

    def get_monitoring_status(self) -> Dict[str, Any]:
        """Get current monitoring status"""
        return {'active': self.monitoring_active, 'uptime': time.time() - getattr(self, 'start_time', time.time()), 'metrics_collected': len(self.metrics_history), 'alerts_generated': len(self.alerts), 'health_checks': len(self.health_checks), 'system_info': self._get_system_info()}

    def run_health_check(self) -> Dict[str, Any]:
        """Run comprehensive health check"""
        results = {'timestamp': datetime.now().isoformat(), 'overall_status': 'healthy', 'checks': [], 'recommendations': []}
        for check in self.health_checks:
            try:
                check_result = check()
                results['checks'].append(check_result)
                if check_result['status'] == 'critical':
                    results['overall_status'] = 'critical'
                elif check_result['status'] == 'warning' and results['overall_status'] == 'healthy':
                    results['overall_status'] = 'warning'
                if check_result.get('recommendation'):
                    results['recommendations'].append(check_result['recommendation'])
            except Exception as e:
                logger.error(f'Health check failed: {e}')
                results['checks'].append({'name': check.__name__, 'status': 'error', 'message': str(e)})
        return results

    def get_recent_metrics(self, minutes: int=5) -> Dict[str, Any]:
        """Get recent performance metrics"""
        cutoff_time = time.time() - minutes * 60
        recent_metrics = [m for m in self.metrics_history if m['timestamp'] > cutoff_time]
        if not recent_metrics:
            return {'status': 'no_data', 'message': f'No metrics in the last {minutes} minutes'}
        aggregated = {}
        for metric in recent_metrics:
            name = metric['name']
            if name not in aggregated:
                aggregated[name] = {'count': 0, 'sum': 0, 'min': float('inf'), 'max': float('-inf'), 'values': []}
            aggregated[name]['count'] += 1
            aggregated[name]['sum'] += metric['value']
            aggregated[name]['min'] = min(aggregated[name]['min'], metric['value'])
            aggregated[name]['max'] = max(aggregated[name]['max'], metric['value'])
            aggregated[name]['values'].append(metric['value'])
        for (name, data) in aggregated.items():
            data['avg'] = data['sum'] / data['count']
            data['latest'] = data['values'][-1] if data['values'] else None
            del data['values']
        return {'time_range_minutes': minutes, 'total_metrics': len(recent_metrics), 'aggregated_metrics': aggregated}

    def get_recent_alerts(self, limit: int=10) -> Dict[str, Any]:
        """Get recent system alerts"""
        recent_alerts = list(self.alerts)[-limit:]
        return {'total_alerts': len(self.alerts), 'recent_alerts': recent_alerts, 'alert_summary': self._summarize_alerts(recent_alerts)}

    def get_optimization_suggestions(self) -> Dict[str, Any]:
        """Get system optimization suggestions"""
        suggestions = []
        metrics = self.get_recent_metrics(30)
        if metrics.get('aggregated_metrics'):
            agg = metrics['aggregated_metrics']
            if 'cpu_percent' in agg and agg['cpu_percent']['avg'] > 70:
                suggestions.append({'type': 'cpu_optimization', 'priority': 'high', 'suggestion': 'High CPU usage detected. Consider optimizing CPU-intensive processes.', 'potential_savings': f"Could reduce CPU usage by {min(agg['cpu_percent']['avg'] - 50, 30):.1f}%"})
            if 'memory_percent' in agg and agg['memory_percent']['avg'] > 80:
                suggestions.append({'type': 'memory_optimization', 'priority': 'high', 'suggestion': 'High memory usage detected. Consider freeing up memory or increasing RAM.', 'potential_savings': f"Could reduce memory usage by {min(agg['memory_percent']['avg'] - 60, 25):.1f}%"})
            if 'disk_percent' in agg and agg['disk_percent']['avg'] > 85:
                suggestions.append({'type': 'disk_optimization', 'priority': 'medium', 'suggestion': 'High disk usage detected. Consider cleaning up temporary files or adding storage.', 'actions': ['Run disk cleanup', 'Remove unnecessary files', 'Consider disk expansion']})
        suggestions.extend([{'type': 'maintenance', 'priority': 'low', 'suggestion': 'Regular system maintenance recommended', 'actions': ['Update system', 'Run antivirus scan', 'Check for software updates']}, {'type': 'monitoring', 'priority': 'low', 'suggestion': 'Consider enabling automated backups', 'actions': ['Set up automated backups', 'Test backup restoration']}])
        return {'suggestions_count': len(suggestions), 'suggestions': suggestions, 'generated_at': datetime.now().isoformat()}

    def _monitoring_loop(self):
        """Main monitoring loop"""
        self.start_time = time.time()
        while self.monitoring_active:
            try:
                metrics = self._collect_system_metrics()
                for (name, value) in metrics.items():
                    self.metrics_history.append({'name': name, 'value': value, 'timestamp': time.time()})
                self._check_alerts(metrics)
                if int(time.time()) % 60 == 0:
                    health_result = self.run_health_check()
                    if health_result['overall_status'] != 'healthy':
                        self._generate_health_alert(health_result)
                time.sleep(self.monitoring_interval)
            except Exception as e:
                logger.error(f'Monitoring loop error: {e}')
                time.sleep(self.monitoring_interval)

    def _collect_system_metrics(self) -> Dict[str, float]:
        """Collect current system metrics"""
        metrics = {}
        try:
            metrics['cpu_percent'] = psutil.cpu_percent(interval=1)
            metrics['cpu_count'] = psutil.cpu_count()
            metrics['cpu_freq'] = psutil.cpu_freq().current if psutil.cpu_freq() else 0
            memory = psutil.virtual_memory()
            metrics['memory_percent'] = memory.percent
            metrics['memory_used'] = memory.used / 1024 ** 3
            metrics['memory_available'] = memory.available / 1024 ** 3
            disk = psutil.disk_usage('/')
            metrics['disk_percent'] = disk.percent
            metrics['disk_used'] = disk.used / 1024 ** 3
            metrics['disk_free'] = disk.free / 1024 ** 3
            network = psutil.net_io_counters()
            metrics['network_bytes_sent'] = network.bytes_sent / 1024 ** 2
            metrics['network_bytes_recv'] = network.bytes_recv / 1024 ** 2
            metrics['process_count'] = len(psutil.pids())
            try:
                load = psutil.getloadavg()
                metrics['system_load_1'] = load[0]
                metrics['system_load_5'] = load[1]
                metrics['system_load_15'] = load[2]
            except:
                pass
        except Exception as e:
            logger.error(f'Failed to collect metrics: {e}')
        return metrics

    def _check_alerts(self, metrics: Dict[str, float]):
        """Check metrics against alert thresholds"""
        alerts_generated = []
        if metrics.get('cpu_percent', 0) > self.alert_thresholds['cpu_percent']:
            alerts_generated.append({'type': 'cpu_high', 'severity': 'warning', 'message': f"CPU usage is {metrics['cpu_percent']:.1f}%, above threshold of {self.alert_thresholds['cpu_percent']}%", 'value': metrics['cpu_percent'], 'threshold': self.alert_thresholds['cpu_percent']})
        if metrics.get('memory_percent', 0) > self.alert_thresholds['memory_percent']:
            alerts_generated.append({'type': 'memory_high', 'severity': 'warning', 'message': f"Memory usage is {metrics['memory_percent']:.1f}%, above threshold of {self.alert_thresholds['memory_percent']}%", 'value': metrics['memory_percent'], 'threshold': self.alert_thresholds['memory_percent']})
        if metrics.get('disk_percent', 0) > self.alert_thresholds['disk_percent']:
            alerts_generated.append({'type': 'disk_high', 'severity': 'critical', 'message': f"Disk usage is {metrics['disk_percent']:.1f}%, above threshold of {self.alert_thresholds['disk_percent']}%", 'value': metrics['disk_percent'], 'threshold': self.alert_thresholds['disk_percent']})
        for alert in alerts_generated:
            alert['timestamp'] = time.time()
            self.alerts.append(alert)
            for callback in self.alert_callbacks:
                try:
                    callback(alert)
                except Exception as e:
                    logger.error(f'Alert callback error: {e}')

    def _setup_health_checks(self):
        """Setup health check functions"""
        self.health_checks = [self._check_cpu_health, self._check_memory_health, self._check_disk_health, self._check_network_health, self._check_process_health, self._check_service_health]

    def _check_cpu_health(self) -> Dict[str, Any]:
        """Check CPU health"""
        try:
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_count = psutil.cpu_count()
            if cpu_percent > 90:
                return {'name': 'cpu_health', 'status': 'critical', 'message': f'CPU usage critically high: {cpu_percent}%', 'recommendation': 'Reduce CPU load or upgrade CPU'}
            elif cpu_percent > 70:
                return {'name': 'cpu_health', 'status': 'warning', 'message': f'CPU usage high: {cpu_percent}%', 'recommendation': 'Monitor CPU usage and optimize processes'}
            else:
                return {'name': 'cpu_health', 'status': 'healthy', 'message': f'CPU usage normal: {cpu_percent}% with {cpu_count} cores'}
        except Exception as e:
            return {'name': 'cpu_health', 'status': 'error', 'message': f'CPU health check failed: {str(e)}'}

    def _check_memory_health(self) -> Dict[str, Any]:
        """Check memory health"""
        try:
            memory = psutil.virtual_memory()
            memory_percent = memory.percent
            if memory_percent > 95:
                return {'name': 'memory_health', 'status': 'critical', 'message': f'Memory usage critically high: {memory_percent}%', 'recommendation': 'Free up memory immediately or add more RAM'}
            elif memory_percent > 85:
                return {'name': 'memory_health', 'status': 'warning', 'message': f'Memory usage high: {memory_percent}%', 'recommendation': 'Close unnecessary applications'}
            else:
                return {'name': 'memory_health', 'status': 'healthy', 'message': f'Memory usage normal: {memory_percent}%'}
        except Exception as e:
            return {'name': 'memory_health', 'status': 'error', 'message': f'Memory health check failed: {str(e)}'}

    def _check_disk_health(self) -> Dict[str, Any]:
        """Check disk health"""
        try:
            disk = psutil.disk_usage('/')
            disk_percent = disk.percent
            if disk_percent > 95:
                return {'name': 'disk_health', 'status': 'critical', 'message': f'Disk usage critically high: {disk_percent}%', 'recommendation': 'Free up disk space immediately'}
            elif disk_percent > 85:
                return {'name': 'disk_health', 'status': 'warning', 'message': f'Disk usage high: {disk_percent}%', 'recommendation': 'Clean up unnecessary files'}
            else:
                return {'name': 'disk_health', 'status': 'healthy', 'message': f'Disk usage normal: {disk_percent}%'}
        except Exception as e:
            return {'name': 'disk_health', 'status': 'error', 'message': f'Disk health check failed: {str(e)}'}

    def _check_network_health(self) -> Dict[str, Any]:
        """Check network health"""
        try:
            network = psutil.net_io_counters()
            return {'name': 'network_health', 'status': 'healthy', 'message': f'Network operational - {network.bytes_sent} bytes sent, {network.bytes_recv} bytes received'}
        except Exception as e:
            return {'name': 'network_health', 'status': 'error', 'message': f'Network health check failed: {str(e)}'}

    def _check_process_health(self) -> Dict[str, Any]:
        """Check process health"""
        try:
            process_count = len(psutil.pids())
            if process_count > 1000:
                return {'name': 'process_health', 'status': 'warning', 'message': f'High process count: {process_count}', 'recommendation': 'Monitor running processes'}
            else:
                return {'name': 'process_health', 'status': 'healthy', 'message': f'Process count normal: {process_count}'}
        except Exception as e:
            return {'name': 'process_health', 'status': 'error', 'message': f'Process health check failed: {str(e)}'}

    def _check_service_health(self) -> Dict[str, Any]:
        """Check service health (placeholder)"""
        return {'name': 'service_health', 'status': 'healthy', 'message': 'All monitored services are running'}

    def _generate_health_alert(self, health_result: Dict[str, Any]):
        """Generate alert from health check result"""
        alert = {'type': 'health_check', 'severity': health_result['overall_status'], 'message': f"Health check completed with status: {health_result['overall_status']}", 'details': health_result, 'timestamp': time.time()}
        self.alerts.append(alert)

    def _get_system_info(self) -> Dict[str, Any]:
        """Get basic system information"""
        return {'platform': platform.platform(), 'processor': platform.processor(), 'python_version': platform.python_version(), 'cpu_count': psutil.cpu_count(), 'total_memory': psutil.virtual_memory().total / 1024 ** 3, 'total_disk': psutil.disk_usage('/').total / 1024 ** 3}

    def _summarize_alerts(self, alerts: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Summarize alerts by type and severity"""
        summary = {'total': len(alerts), 'by_type': {}, 'by_severity': {}}
        for alert in alerts:
            alert_type = alert.get('type', 'unknown')
            severity = alert.get('severity', 'unknown')
            summary['by_type'][alert_type] = summary['by_type'].get(alert_type, 0) + 1
            summary['by_severity'][severity] = summary['by_severity'].get(severity, 0) + 1
        return summary

    def add_alert_callback(self, callback: Callable):
        """Add callback for alerts"""
        self.alert_callbacks.append(callback)

    def remove_alert_callback(self, callback: Callable):
        """Remove alert callback"""
        if callback in self.alert_callbacks:
            self.alert_callbacks.remove(callback)