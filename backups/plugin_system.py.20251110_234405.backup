from functools import lru_cache
'\nplugin_system.py - Dynamic Plugin Management for Neo-Clone\n\nImplements:\n- Hot-swappable skill modules\n- Plugin discovery and loading\n- Plugin lifecycle management\n- Safe plugin execution with isolation\n- Plugin registry and metadata\n- Custom command extensions\n'
import os
import sys
import importlib
import importlib.util
import json
import logging
import threading
from pathlib import Path
from typing import Dict, Any, List, Optional, Type
from abc import ABC, abstractmethod
from dataclasses import dataclass, asdict
import inspect
logger = logging.getLogger(__name__)

@dataclass
class PluginMetadata:
    name: str
    version: str
    description: str
    author: str
    dependencies: List[str]
    main_class: Optional[str] = None
    entry_point: Optional[str] = None
    config_schema: Optional[Dict[str, Any]] = None

class BasePlugin(ABC):
    """Base class for all Neo-Clone plugins"""

    @property
    @abstractmethod
    def name(self) -> str:
        pass

    @property
    @abstractmethod
    def version(self) -> str:
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        pass

    @property
    def author(self) -> str:
        return 'Unknown'

    @property
    def dependencies(self) -> List[str]:
        return []

    def initialize(self, config: Dict[str, Any]) -> bool:
        """Initialize plugin with configuration"""
        return True

    def shutdown(self):
        """Clean shutdown of plugin"""
        pass

    def get_config_schema(self) -> Dict[str, Any]:
        """Return configuration schema for the plugin"""
        return {}

class PluginManager:
    """Manages plugin lifecycle and execution"""

    def __init__(self, plugin_dir: str='plugins'):
        self.plugin_dir = Path(plugin_dir)
        self.plugin_dir.mkdir(exist_ok=True)
        self.loaded_plugins: Dict[str, BasePlugin] = {}
        self.plugin_metadata: Dict[str, PluginMetadata] = {}
        self.plugin_configs: Dict[str, Dict[str, Any]] = {}
        self._lock = threading.Lock()
        self.discover_plugins()
        self.load_enabled_plugins()

    def discover_plugins(self):
        """Discover available plugins in the plugin directory"""
        logger.info(f'Discovering plugins in {self.plugin_dir}')
        for plugin_file in self.plugin_dir.glob('*.py'):
            if plugin_file.name.startswith('__'):
                continue
            try:
                plugin_name = plugin_file.stem
                metadata = self._load_plugin_metadata(plugin_file, plugin_name)
                if metadata:
                    self.plugin_metadata[plugin_name] = metadata
                    logger.info(f'Discovered plugin: {plugin_name} v{metadata.version}')
                else:
                    logger.warning(f'Invalid plugin metadata: {plugin_name}')
            except Exception as e:
                logger.error(f'Failed to discover plugin {plugin_file}: {e}')

    @lru_cache(maxsize=128)
    def _load_plugin_metadata(self, plugin_file: Path, plugin_name: str) -> Optional[PluginMetadata]:
        """Load plugin metadata from file"""
        try:
            metadata_file = plugin_file.parent / f'{plugin_name}.meta'
            if metadata_file.exists():
                with open(metadata_file, 'r') as f:
                    data = json.load(f)
                    return PluginMetadata(**data)
            spec = importlib.util.spec_from_file_location(plugin_name, plugin_file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                if hasattr(module, 'PLUGIN_METADATA'):
                    return PluginMetadata(**module.PLUGIN_METADATA)
                elif hasattr(module, '__plugin_metadata__'):
                    return PluginMetadata(**module.__plugin_metadata__)
                plugin_class = None
                for attr_name in dir(module):
                    attr = getattr(module, attr_name)
                    if isinstance(attr, type) and issubclass(attr, BasePlugin) and (attr is not BasePlugin):
                        plugin_class = attr
                        break
                if plugin_class:
                    return PluginMetadata(name=getattr(plugin_class, 'name', plugin_name), version=getattr(plugin_class, 'version', '1.0.0'), description=getattr(plugin_class, 'description', 'No description'), author=getattr(plugin_class, 'author', 'Unknown'), dependencies=getattr(plugin_class, 'dependencies', []))
            return None
        except Exception as e:
            logger.error(f'Failed to load metadata for {plugin_name}: {e}')
            return None

    def load_plugin(self, plugin_name: str, config: Optional[Dict[str, Any]]=None) -> bool:
        """Load and initialize a specific plugin"""
        with self._lock:
            if plugin_name in self.loaded_plugins:
                logger.warning(f'Plugin {plugin_name} already loaded')
                return True
            try:
                metadata = self.plugin_metadata.get(plugin_name)
                if metadata and metadata.dependencies:
                    for dep in metadata.dependencies:
                        if dep not in self.loaded_plugins:
                            logger.error(f'Plugin {plugin_name} depends on {dep} which is not loaded')
                            return False
                plugin_file = self.plugin_dir / f'{plugin_name}.py'
                if not plugin_file.exists():
                    logger.error(f'Plugin file not found: {plugin_file}')
                    return False
                spec = importlib.util.spec_from_file_location(plugin_name, plugin_file)
                if not spec or not spec.loader:
                    logger.error(f'Failed to create module spec for {plugin_name}')
                    return False
                module = importlib.util.module_from_spec(spec)
                sys.modules[plugin_name] = module
                spec.loader.exec_module(module)
                plugin_class = None
                for attr_name in dir(module):
                    attr = getattr(module, attr_name)
                    if isinstance(attr, type) and issubclass(attr, BasePlugin) and (attr is not BasePlugin):
                        plugin_class = attr
                        break
                if not plugin_class:
                    logger.error(f'No valid plugin class found in {plugin_name}')
                    return False
                plugin_instance = plugin_class()
                if config:
                    self.plugin_configs[plugin_name] = config
                    if not plugin_instance.initialize(config):
                        logger.error(f'Plugin {plugin_name} initialization failed')
                        return False
                self.loaded_plugins[plugin_name] = plugin_instance
                logger.info(f'Successfully loaded plugin: {plugin_name}')
                return True
            except Exception as e:
                logger.error(f'Failed to load plugin {plugin_name}: {e}')
                return False

    def unload_plugin(self, plugin_name: str) -> bool:
        """Unload a specific plugin"""
        with self._lock:
            if plugin_name not in self.loaded_plugins:
                logger.warning(f'Plugin {plugin_name} is not loaded')
                return True
            try:
                plugin = self.loaded_plugins[plugin_name]
                plugin.shutdown()
                del self.loaded_plugins[plugin_name]
                if plugin_name in sys.modules:
                    del sys.modules[plugin_name]
                logger.info(f'Unloaded plugin: {plugin_name}')
                return True
            except Exception as e:
                logger.error(f'Failed to unload plugin {plugin_name}: {e}')
                return False

    def reload_plugin(self, plugin_name: str) -> bool:
        """Reload a plugin (useful for development)"""
        if plugin_name in self.loaded_plugins:
            self.unload_plugin(plugin_name)
        return self.load_plugin(plugin_name)

    def load_enabled_plugins(self):
        """Load all plugins that are marked as enabled"""
        enabled_plugins = self._get_enabled_plugins()
        for plugin_name in enabled_plugins:
            if plugin_name in self.plugin_metadata:
                config = self.plugin_configs.get(plugin_name, {})
                self.load_plugin(plugin_name, config)

    def _get_enabled_plugins(self) -> List[str]:
        """Get list of enabled plugins from config"""
        try:
            config_file = self.plugin_dir / 'plugins.json'
            if config_file.exists():
                with open(config_file, 'r') as f:
                    data = json.load(f)
                    return [name for (name, config) in data.items() if config.get('enabled', False)]
        except Exception as e:
            logger.warning(f'Failed to load plugin config: {e}')
        return []

    def get_loaded_plugins(self) -> List[str]:
        """Get list of loaded plugin names"""
        return list(self.loaded_plugins.keys())

    def get_plugin(self, plugin_name: str) -> Optional[BasePlugin]:
        """Get loaded plugin instance"""
        return self.loaded_plugins.get(plugin_name)

    def get_plugin_info(self, plugin_name: str) -> Optional[Dict[str, Any]]:
        """Get detailed information about a plugin"""
        metadata = self.plugin_metadata.get(plugin_name)
        plugin = self.loaded_plugins.get(plugin_name)
        if not metadata and (not plugin):
            return None
        info = {'name': plugin_name, 'loaded': plugin is not None, 'metadata': asdict(metadata) if metadata else None}
        if plugin:
            info.update({'instance_available': True, 'config': self.plugin_configs.get(plugin_name, {}), 'capabilities': self._get_plugin_capabilities(plugin)})
        return info

    def _get_plugin_capabilities(self, plugin: BasePlugin) -> List[str]:
        """Get capabilities provided by a plugin"""
        capabilities = []
        if hasattr(plugin, 'commands'):
            capabilities.append('custom_commands')
        if hasattr(plugin, 'skills'):
            capabilities.append('skill_providers')
        if hasattr(plugin, 'processors'):
            capabilities.append('message_processors')
        if hasattr(plugin, 'apis'):
            capabilities.append('api_extensions')
        return capabilities

    def execute_plugin_method(self, plugin_name: str, method_name: str, *args, **kwargs) -> Any:
        """Safely execute a method on a loaded plugin"""
        plugin = self.loaded_plugins.get(plugin_name)
        if not plugin:
            raise ValueError(f'Plugin {plugin_name} is not loaded')
        if not hasattr(plugin, method_name):
            raise AttributeError(f'Plugin {plugin_name} does not have method {method_name}')
        method = getattr(plugin, method_name)
        if not callable(method):
            raise TypeError(f'{method_name} is not callable')
        try:
            return method(*args, **kwargs)
        except Exception as e:
            logger.error(f'Plugin {plugin_name} method {method_name} failed: {e}')
            raise

    def list_all_plugins(self) -> Dict[str, Dict[str, Any]]:
        """List all discovered plugins with their status"""
        result = {}
        for name in self.plugin_metadata.keys():
            result[name] = self.get_plugin_info(name)
        return result

    def create_plugin_template(self, plugin_name: str, plugin_type: str='basic') -> bool:
        """Create a plugin template file"""
        template_dir = self.plugin_dir
        template_file = template_dir / f'{plugin_name}.py'
        metadata_file = template_dir / f'{plugin_name}.meta'
        if template_file.exists():
            logger.warning(f'Plugin {plugin_name} already exists')
            return False
        try:
            template_content = self._generate_plugin_template(plugin_name, plugin_type)
            with open(template_file, 'w') as f:
                f.write(template_content)
            metadata_content = self._generate_metadata_template(plugin_name, plugin_type)
            with open(metadata_file, 'w') as f:
                f.write(json.dumps(metadata_content, indent=2))
            logger.info(f'Created plugin template: {plugin_name}')
            return True
        except Exception as e:
            logger.error(f'Failed to create plugin template: {e}')
            return False

    def _generate_plugin_template(self, plugin_name: str, plugin_type: str) -> str:
        """Generate plugin code template"""
        if plugin_type == 'basic':
            return f'''"""\n{plugin_name}.py - Example Plugin for Neo-Clone\n\nThis is a template plugin. Modify according to your needs.\n"""\n\nfrom plugin_system import BasePlugin\nfrom typing import Dict, Any\n\nclass {plugin_name.replace('_', '').title()}Plugin(BasePlugin):\n    """Example plugin class"""\n    \n    @property\n    def name(self) -> str:\n        return "{plugin_name}"\n    \n    @property\n    def version(self) -> str:\n        return "1.0.0"\n    \n    @property\n    def description(self) -> str:\n        return "Example plugin for Neo-Clone"\n    \n    @property\n    def author(self) -> str:\n        return "Your Name"\n    \n    def initialize(self, config: Dict[str, Any]) -> bool:\n        """Initialize plugin"""\n        # Add your initialization code here\n        return True\n    \n    def shutdown(self):\n        """Clean shutdown"""\n        # Add your cleanup code here\n        pass\n    \n    def example_method(self) -> str:\n        """Example method that can be called"""\n        return f"Hello from {self.name} plugin!"\n\n# Plugin metadata\nPLUGIN_METADATA = {{\n    "name": "{plugin_name}",\n    "version": "1.0.0",\n    "description": "Example plugin for Neo-Clone",\n    "author": "Your Name",\n    "dependencies": []\n}}\n\n# Create plugin instance\nplugin = {plugin_name.replace('_', '').title()}Plugin()\n'''
        else:
            return f'# Plugin template for {plugin_name} ({plugin_type})'

    def _generate_metadata_template(self, plugin_name: str, plugin_type: str) -> Dict[str, Any]:
        """Generate metadata template"""
        return {'name': plugin_name, 'version': '1.0.0', 'description': f'Example {plugin_type} plugin for Neo-Clone', 'author': 'Your Name', 'dependencies': [], 'main_class': f"{plugin_name.replace('_', '').title()}Plugin"}
_plugin_manager_instance = None

def get_plugin_manager() -> PluginManager:
    """Get global plugin manager instance (singleton pattern)"""
    global _plugin_manager_instance
    if _plugin_manager_instance is None:
        _plugin_manager_instance = PluginManager()
    return _plugin_manager_instance

def plugin_method(name: str=None):
    """Decorator to mark methods as plugin capabilities"""

    def decorator(func):
        func._plugin_method_name = name or func.__name__
        return func
    return decorator

def skill_provider(skill_name: str):
    """Decorator to register a function as a skill provider"""

    def decorator(func):
        func._is_skill_provider = True
        func._skill_name = skill_name
        return func
    return decorator

def load_plugin_skill(plugin_name: str, config: Optional[Dict[str, Any]]=None):
    """Load a skill from a plugin"""
    plugin_manager = get_plugin_manager()
    return plugin_manager.load_plugin(plugin_name, config)