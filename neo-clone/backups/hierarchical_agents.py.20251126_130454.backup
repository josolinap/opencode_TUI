from functools import lru_cache
'\nHierarchical Agent Architecture with Meta-Agents for Neo-Clone\nImplements multi-level agent coordination and meta-reasoning\n'
import asyncio
import numpy as np
import json
import time
import logging
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
from collections import defaultdict
import uuid
logger = logging.getLogger(__name__)

class AgentLevel(Enum):
    """Hierarchical levels of agents"""
    META = 'meta'
    EXECUTIVE = 'executive'
    MANAGER = 'manager'
    WORKER = 'worker'
    SPECIALIST = 'specialist'

class AgentRole(Enum):
    """Roles within the hierarchy"""
    COORDINATOR = 'coordinator'
    PLANNER = 'planner'
    OPTIMIZER = 'optimizer'
    MONITOR = 'monitor'
    EXECUTOR = 'executor'
    ANALYST = 'analyst'
    CREATOR = 'creator'
    INTEGRATOR = 'integrator'

@dataclass
class AgentCapability:
    """Represents a specific agent capability"""
    name: str
    proficiency: float
    efficiency: float
    reliability: float
    cost_per_use: float
    dependencies: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class AgentTask:
    """Represents a task for agents"""
    task_id: str
    description: str
    required_capabilities: List[str]
    priority: int
    complexity: float
    deadline: Optional[float] = None
    constraints: Dict[str, Any] = field(default_factory=dict)
    subtasks: List['AgentTask'] = field(default_factory=list)
    parent_task: Optional[str] = None
    status: str = 'pending'

@dataclass
class HierarchicalAgent:
    """Represents an agent in the hierarchy"""
    agent_id: str
    name: str
    level: AgentLevel
    role: AgentRole
    capabilities: List[AgentCapability]
    parent_agent: Optional[str] = None
    child_agents: List[str] = field(default_factory=list)
    performance_metrics: Dict[str, float] = field(default_factory=dict)
    current_tasks: List[str] = field(default_factory=list)
    completed_tasks: List[str] = field(default_factory=list)
    availability: float = 1.0
    workload: float = 0.0
    max_workload: float = 1.0
    metadata: Dict[str, Any] = field(default_factory=dict)

class MetaAgent:
    """Meta-agent for high-level coordination and strategy"""

    def __init__(self, agent_id: str, name: str):
        self.agent_id = agent_id
        self.name = name
        self.level = AgentLevel.META
        self.role = AgentRole.COORDINATOR
        self.strategic_planning = AgentCapability(name='strategic_planning', proficiency=0.95, efficiency=0.8, reliability=0.9, cost_per_use=0.1)
        self.system_optimization = AgentCapability(name='system_optimization', proficiency=0.9, efficiency=0.85, reliability=0.95, cost_per_use=0.08)
        self.meta_reasoning = AgentCapability(name='meta_reasoning', proficiency=0.92, efficiency=0.75, reliability=0.88, cost_per_use=0.12)
        self.capabilities = [self.strategic_planning, self.system_optimization, self.meta_reasoning]
        self.system_state = {}
        self.strategic_goals = []
        self.optimization_history = []
        self.coordination_patterns = {}

    def analyze_system_state(self, agents: Dict[str, HierarchicalAgent], tasks: Dict[str, AgentTask]) -> Dict[str, Any]:
        """Analyze overall system state and identify optimization opportunities"""
        agent_performance = {}
        for (agent_id, agent) in agents.items():
            if agent.level != AgentLevel.META:
                performance = self._analyze_agent_performance(agent)
                agent_performance[agent_id] = performance
        task_analysis = self._analyze_task_distribution(tasks)
        system_efficiency = self._calculate_system_efficiency(agents, tasks)
        bottlenecks = self._identify_bottlenecks(agents, tasks)
        opportunities = self._identify_optimization_opportunities(agent_performance, task_analysis, system_efficiency, bottlenecks)
        system_state = {'timestamp': time.time(), 'agent_performance': agent_performance, 'task_analysis': task_analysis, 'system_efficiency': system_efficiency, 'bottlenecks': bottlenecks, 'optimization_opportunities': opportunities, 'overall_health': self._calculate_system_health(agent_performance, system_efficiency)}
        self.system_state = system_state
        return system_state

    def generate_strategic_plan(self, system_state: Dict[str, Any], strategic_objectives: List[str]) -> Dict[str, Any]:
        """Generate strategic plan for system optimization"""
        gap_analysis = self._analyze_strategic_gaps(system_state, strategic_objectives)
        initiatives = self._generate_strategic_initiatives(gap_analysis)
        roadmap = self._create_implementation_roadmap(initiatives)
        resource_allocation = self._plan_resource_allocation(roadmap)
        success_metrics = self._define_success_metrics(strategic_objectives, initiatives)
        strategic_plan = {'timestamp': time.time(), 'strategic_objectives': strategic_objectives, 'gap_analysis': gap_analysis, 'strategic_initiatives': initiatives, 'implementation_roadmap': roadmap, 'resource_allocation': resource_allocation, 'success_metrics': success_metrics, 'estimated_completion': self._estimate_completion_time(roadmap), 'risk_assessment': self._assess_strategic_risks(initiatives)}
        self.strategic_goals = strategic_objectives
        return strategic_plan

    def coordinate_agents(self, agents: Dict[str, HierarchicalAgent], tasks: Dict[str, AgentTask]) -> Dict[str, Any]:
        """Coordinate agent activities for optimal performance"""
        task_assignments = self._decompose_and_assign_tasks(tasks, agents)
        workload_balancing = self._balance_workloads(task_assignments, agents)
        communication_plan = self._setup_communication(task_assignments, agents)
        conflict_resolution = self._resolve_conflicts(task_assignments, agents)
        monitoring_plan = self._setup_performance_monitoring(task_assignments, agents)
        coordination_plan = {'timestamp': time.time(), 'task_assignments': task_assignments, 'workload_balancing': workload_balancing, 'communication_plan': communication_plan, 'conflict_resolution': conflict_resolution, 'monitoring_plan': monitoring_plan, 'coordination_efficiency': self._calculate_coordination_efficiency(task_assignments, agents)}
        self.coordination_patterns = coordination_plan
        return coordination_plan

    @lru_cache(maxsize=128)
    def optimize_system(self, agents: Dict[str, HierarchicalAgent], tasks: Dict[str, AgentTask]) -> Dict[str, Any]:
        """Perform system-wide optimization"""
        baseline = self._measure_baseline_performance(agents, tasks)
        optimization_targets = self._identify_optimization_targets(agents, tasks)
        optimization_results = {}
        for target in optimization_targets:
            if target['type'] == 'workload_balancing':
                result = self._optimize_workload_balancing(agents, tasks)
                optimization_results['workload_balancing'] = result
            elif target['type'] == 'task_routing':
                result = self._optimize_task_routing(agents, tasks)
                optimization_results['task_routing'] = result
            elif target['type'] == 'resource_allocation':
                result = self._optimize_resource_allocation(agents, tasks)
                optimization_results['resource_allocation'] = result
            elif target['type'] == 'agent_coordination':
                result = self._optimize_agent_coordination(agents, tasks)
                optimization_results['agent_coordination'] = result
        optimized_performance = self._measure_optimized_performance(agents, tasks, optimization_results)
        improvement = self._calculate_improvement(baseline, optimized_performance)
        optimization_report = {'timestamp': time.time(), 'baseline_performance': baseline, 'optimization_targets': optimization_targets, 'optimization_results': optimization_results, 'optimized_performance': optimized_performance, 'improvement_metrics': improvement, 'optimization_success': improvement['overall_improvement'] > 0.1, 'recommendations': self._generate_optimization_recommendations(optimization_results, improvement)}
        self.optimization_history.append(optimization_report)
        return optimization_report

    def _analyze_agent_performance(self, agent: HierarchicalAgent) -> Dict[str, Any]:
        """Analyze individual agent performance"""
        task_completion_rate = 0.0
        if agent.completed_tasks:
            task_completion_rate = len(agent.completed_tasks) / (len(agent.completed_tasks) + len(agent.current_tasks))
        capability_utilization = np.mean([cap.proficiency * cap.efficiency for cap in agent.capabilities]) if agent.capabilities else 0.0
        workload_efficiency = 1.0 - agent.workload / agent.max_workload
        reliability_score = np.mean([cap.reliability for cap in agent.capabilities]) if agent.capabilities else 0.0
        overall_performance = 0.3 * task_completion_rate + 0.3 * capability_utilization + 0.2 * workload_efficiency + 0.2 * reliability_score
        return {'agent_id': agent.agent_id, 'task_completion_rate': task_completion_rate, 'capability_utilization': capability_utilization, 'workload_efficiency': workload_efficiency, 'reliability_score': reliability_score, 'overall_performance': overall_performance, 'availability': agent.availability, 'current_workload': agent.workload, 'performance_trend': self._calculate_performance_trend(agent)}

    def _analyze_task_distribution(self, tasks: Dict[str, AgentTask]) -> Dict[str, Any]:
        """Analyze task distribution and characteristics"""
        if not tasks:
            return {'status': 'no_tasks'}
        total_tasks = len(tasks)
        completed_tasks = len([t for t in tasks.values() if t.status == 'completed'])
        in_progress_tasks = len([t for t in tasks.values() if t.status == 'in_progress'])
        priorities = [t.priority for t in tasks.values()]
        avg_priority = np.mean(priorities) if priorities else 0.0
        complexities = [t.complexity for t in tasks.values()]
        avg_complexity = np.mean(complexities) if complexities else 0.0
        task_types = defaultdict(int)
        for task in tasks.values():
            for capability in task.required_capabilities:
                task_types[capability] += 1
        return {'total_tasks': total_tasks, 'completed_tasks': completed_tasks, 'in_progress_tasks': in_progress_tasks, 'completion_rate': completed_tasks / total_tasks if total_tasks > 0 else 0.0, 'average_priority': avg_priority, 'average_complexity': avg_complexity, 'task_types': dict(task_types), 'task_backlog': len([t for t in tasks.values() if t.status == 'pending'])}

    def _calculate_system_efficiency(self, agents: Dict[str, HierarchicalAgent], tasks: Dict[str, AgentTask]) -> Dict[str, Any]:
        """Calculate overall system efficiency"""
        if not agents:
            return {'status': 'no_agents'}
        agent_efficiencies = []
        for agent in agents.values():
            if agent.level != AgentLevel.META:
                efficiency = self._analyze_agent_performance(agent)['overall_performance']
                agent_efficiencies.append(efficiency)
        avg_agent_efficiency = np.mean(agent_efficiencies) if agent_efficiencies else 0.0
        task_efficiency = 0.0
        if tasks:
            completed = len([t for t in tasks.values() if t.status == 'completed'])
            task_efficiency = completed / len(tasks)
        total_workload = sum((a.workload for a in agents.values() if a.level != AgentLevel.META))
        max_total_workload = sum((a.max_workload for a in agents.values() if a.level != AgentLevel.META))
        resource_utilization = total_workload / max_total_workload if max_total_workload > 0 else 0.0
        system_efficiency = 0.4 * avg_agent_efficiency + 0.4 * task_efficiency + 0.2 * (1.0 - abs(resource_utilization - 0.7))
        return {'agent_efficiency': avg_agent_efficiency, 'task_efficiency': task_efficiency, 'resource_utilization': resource_utilization, 'system_efficiency': system_efficiency, 'efficiency_trend': self._calculate_efficiency_trend()}

    def _identify_bottlenecks(self, agents: Dict[str, HierarchicalAgent], tasks: Dict[str, AgentTask]) -> List[Dict[str, Any]]:
        """Identify system bottlenecks"""
        bottlenecks = []
        for agent in agents.values():
            if agent.level != AgentLevel.META and agent.workload > agent.max_workload * 0.9:
                bottlenecks.append({'type': 'workload', 'agent_id': agent.agent_id, 'severity': 'high' if agent.workload > agent.max_workload else 'medium', 'description': f'Agent {agent.name} is overloaded', 'impact': 'Reduced performance and potential task delays'})
        capability_demands = defaultdict(int)
        for task in tasks.values():
            if task.status in ['pending', 'in_progress']:
                for capability in task.required_capabilities:
                    capability_demands[capability] += 1
        capability_supply = defaultdict(int)
        for agent in agents.values():
            if agent.level != AgentLevel.META:
                for capability in agent.capabilities:
                    capability_supply[capability.name] += 1
        for (capability, demand) in capability_demands.items():
            supply = capability_supply.get(capability, 0)
            if demand > supply * 0.8:
                bottlenecks.append({'type': 'capability', 'capability': capability, 'severity': 'high' if demand > supply else 'medium', 'description': f'High demand for {capability} capability', 'impact': 'Task delays and reduced quality'})
        for task in tasks.values():
            if task.status == 'pending' and task.subtasks:
                incomplete_subtasks = []
                for st in task.subtasks:
                    subtask = tasks.get(st) if isinstance(st, str) else None
                    if subtask and subtask.status != 'completed':
                        incomplete_subtasks.append(st)
                if incomplete_subtasks:
                    bottlenecks.append({'type': 'dependency', 'task_id': task.task_id, 'severity': 'medium', 'description': f'Task {task.task_id} blocked by dependencies', 'impact': 'Task cannot start until dependencies complete'})
        return bottlenecks

    def _identify_optimization_opportunities(self, agent_performance: Dict[str, Any], task_analysis: Dict[str, Any], system_efficiency: Dict[str, Any], bottlenecks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Identify opportunities for system optimization"""
        opportunities = []
        low_performers = [agent_id for (agent_id, perf) in agent_performance.items() if perf['overall_performance'] < 0.6]
        if low_performers:
            opportunities.append({'type': 'performance_improvement', 'priority': 'high', 'description': 'Improve performance of underperforming agents', 'target_agents': low_performers, 'expected_impact': '20-30% performance increase'})
        if system_efficiency.get('resource_utilization', 0) > 0.85:
            opportunities.append({'type': 'workload_balancing', 'priority': 'high', 'description': 'Redistribute workload to prevent overload', 'expected_impact': '15-25% efficiency improvement'})
        if task_analysis.get('completion_rate', 0) < 0.7:
            opportunities.append({'type': 'task_routing', 'priority': 'medium', 'description': 'Optimize task assignment and routing', 'expected_impact': '10-20% completion rate improvement'})
        if bottlenecks:
            opportunities.append({'type': 'bottleneck_resolution', 'priority': 'high', 'description': 'Resolve identified system bottlenecks', 'target_bottlenecks': bottlenecks, 'expected_impact': '25-40% system improvement'})
        return opportunities

    def _calculate_system_health(self, agent_performance: Dict[str, Any], system_efficiency: Dict[str, Any]) -> float:
        """Calculate overall system health score"""
        if not agent_performance:
            return 0.0
        avg_agent_health = np.mean([perf['overall_performance'] for perf in agent_performance.values()])
        efficiency_health = system_efficiency.get('system_efficiency', 0.0)
        overall_health = 0.6 * avg_agent_health + 0.4 * efficiency_health
        return max(0.0, min(1.0, overall_health))

    def _calculate_performance_trend(self, agent: HierarchicalAgent) -> str:
        """Calculate performance trend for an agent"""
        return 'stable'

    def _calculate_efficiency_trend(self) -> str:
        """Calculate system efficiency trend"""
        return 'improving' if self.optimization_history else 'stable'

    def _analyze_strategic_gaps(self, system_state: Dict[str, Any], objectives: List[str]) -> Dict[str, Any]:
        """Analyze gaps between current state and strategic objectives"""
        return {'gaps': [], 'priority_gaps': []}

    def _generate_strategic_initiatives(self, gap_analysis: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate strategic initiatives to address gaps"""
        return []

    def _create_implementation_roadmap(self, initiatives: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Create implementation roadmap for initiatives"""
        return {'phases': [], 'timeline': {}}

    def _plan_resource_allocation(self, roadmap: Dict[str, Any]) -> Dict[str, Any]:
        """Plan resource allocation for roadmap"""
        return {'allocation': {}, 'budget': {}}

    def _define_success_metrics(self, objectives: List[str], initiatives: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Define success metrics for strategic plan"""
        return {'metrics': [], 'targets': {}}

    def _estimate_completion_time(self, roadmap: Dict[str, Any]) -> float:
        """Estimate completion time for roadmap"""
        return 30.0

    def _assess_strategic_risks(self, initiatives: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Assess risks associated with strategic initiatives"""
        return []

    def _decompose_and_assign_tasks(self, tasks: Dict[str, AgentTask], agents: Dict[str, HierarchicalAgent]) -> Dict[str, Any]:
        """Decompose tasks and assign to appropriate agents"""
        assignments = {}
        for (task_id, task) in tasks.items():
            suitable_agents = [agent_id for (agent_id, agent) in agents.items() if agent.level != AgentLevel.META and agent.availability > 0.5]
            if suitable_agents:
                assignments[task_id] = suitable_agents[0]
        return assignments

    def _balance_workloads(self, assignments: Dict[str, Any], agents: Dict[str, HierarchicalAgent]) -> Dict[str, Any]:
        """Balance workloads across agents"""
        return {'reassignments': [], 'balanced': True}

    def _setup_communication(self, assignments: Dict[str, Any], agents: Dict[str, HierarchicalAgent]) -> Dict[str, Any]:
        """Setup communication patterns between agents"""
        return {'channels': [], 'protocols': {}}

    def _resolve_conflicts(self, assignments: Dict[str, Any], agents: Dict[str, HierarchicalAgent]) -> Dict[str, Any]:
        """Resolve conflicts in task assignments"""
        return {'conflicts': [], 'resolutions': []}

    def _setup_performance_monitoring(self, assignments: Dict[str, Any], agents: Dict[str, HierarchicalAgent]) -> Dict[str, Any]:
        """Setup performance monitoring for agents and tasks"""
        return {'monitors': [], 'metrics': []}

    def _calculate_coordination_efficiency(self, assignments: Dict[str, Any], agents: Dict[str, HierarchicalAgent]) -> float:
        """Calculate coordination efficiency"""
        return 0.8

    def _measure_baseline_performance(self, agents: Dict[str, HierarchicalAgent], tasks: Dict[str, AgentTask]) -> Dict[str, Any]:
        """Measure baseline system performance"""
        return {'performance': 0.7, 'efficiency': 0.6}

    def _identify_optimization_targets(self, agents: Dict[str, HierarchicalAgent], tasks: Dict[str, AgentTask]) -> List[Dict[str, Any]]:
        """Identify targets for optimization"""
        return [{'type': 'workload_balancing', 'priority': 'high'}, {'type': 'task_routing', 'priority': 'medium'}]

    def _optimize_workload_balancing(self, agents: Dict[str, HierarchicalAgent], tasks: Dict[str, AgentTask]) -> Dict[str, Any]:
        """Optimize workload balancing across agents"""
        return {'improvement': 0.15, 'actions': []}

    def _optimize_task_routing(self, agents: Dict[str, HierarchicalAgent], tasks: Dict[str, AgentTask]) -> Dict[str, Any]:
        """Optimize task routing and assignment"""
        return {'improvement': 0.12, 'actions': []}

    def _optimize_resource_allocation(self, agents: Dict[str, HierarchicalAgent], tasks: Dict[str, AgentTask]) -> Dict[str, Any]:
        """Optimize resource allocation"""
        return {'improvement': 0.1, 'actions': []}

    def _optimize_agent_coordination(self, agents: Dict[str, HierarchicalAgent], tasks: Dict[str, AgentTask]) -> Dict[str, Any]:
        """Optimize agent coordination patterns"""
        return {'improvement': 0.08, 'actions': []}

    def _measure_optimized_performance(self, agents: Dict[str, HierarchicalAgent], tasks: Dict[str, AgentTask], optimization_results: Dict[str, Any]) -> Dict[str, Any]:
        """Measure performance after optimization"""
        return {'performance': 0.85, 'efficiency': 0.78}

    def _calculate_improvement(self, baseline: Dict[str, Any], optimized: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate improvement metrics"""
        perf_improvement = (optimized['performance'] - baseline['performance']) / baseline['performance']
        eff_improvement = (optimized['efficiency'] - baseline['efficiency']) / baseline['efficiency']
        overall_improvement = (perf_improvement + eff_improvement) / 2
        return {'performance_improvement': perf_improvement, 'efficiency_improvement': eff_improvement, 'overall_improvement': overall_improvement}

    def _generate_optimization_recommendations(self, results: Dict[str, Any], improvement: Dict[str, Any]) -> List[str]:
        """Generate optimization recommendations"""
        recommendations = []
        if improvement['overall_improvement'] > 0.2:
            recommendations.append('Continue optimization strategies - showing excellent results')
        elif improvement['overall_improvement'] > 0.1:
            recommendations.append('Optimization is effective - consider fine-tuning parameters')
        else:
            recommendations.append('Review optimization strategies - limited improvement observed')
        return recommendations

class HierarchicalAgentManager:
    """Manager for hierarchical agent system"""

    def __init__(self):
        self.agents = {}
        self.meta_agent = None
        self.tasks = {}
        self.coordination_history = []
        self.optimization_history = []

    def initialize_hierarchy(self, agent_configs: List[Dict[str, Any]]):
        """Initialize hierarchical agent system"""
        self.meta_agent = MetaAgent(agent_id='meta_coordinator', name='System Meta-Coordinator')
        self.agents[self.meta_agent.agent_id] = HierarchicalAgent(agent_id=self.meta_agent.agent_id, name=self.meta_agent.name, level=AgentLevel.META, role=AgentRole.COORDINATOR, capabilities=self.meta_agent.capabilities)
        for config in agent_configs:
            agent = self._create_agent(config)
            self.agents[agent.agent_id] = agent
            if config.get('parent_agent'):
                agent.parent_agent = config['parent_agent']
                parent = self.agents.get(config['parent_agent'])
                if parent:
                    parent.child_agents.append(agent.agent_id)
        logger.info(f'Initialized hierarchical system with {len(self.agents)} agents')

    def _create_agent(self, config: Dict[str, Any]) -> HierarchicalAgent:
        """Create a hierarchical agent from configuration"""
        capabilities = []
        for cap_config in config.get('capabilities', []):
            capability = AgentCapability(name=cap_config['name'], proficiency=cap_config.get('proficiency', 0.7), efficiency=cap_config.get('efficiency', 0.8), reliability=cap_config.get('reliability', 0.9), cost_per_use=cap_config.get('cost_per_use', 0.05))
            capabilities.append(capability)
        agent = HierarchicalAgent(agent_id=config['id'], name=config['name'], level=AgentLevel(config.get('level', 'worker')), role=AgentRole(config.get('role', 'executor')), capabilities=capabilities, max_workload=config.get('max_workload', 1.0), metadata=config.get('metadata', {}))
        return agent

    def coordinate_system(self, strategic_objectives: Optional[List[str]]=None) -> Dict[str, Any]:
        """Coordinate the entire hierarchical system"""
        if not self.meta_agent:
            return {'status': 'no_meta_agent'}
        system_state = self.meta_agent.analyze_system_state(self.agents, self.tasks)
        strategic_plan = None
        if strategic_objectives:
            strategic_plan = self.meta_agent.generate_strategic_plan(system_state, strategic_objectives)
        coordination = self.meta_agent.coordinate_agents(self.agents, self.tasks)
        optimization = self.meta_agent.optimize_system(self.agents, self.tasks)
        coordination_report = {'timestamp': time.time(), 'system_state': system_state, 'strategic_plan': strategic_plan, 'coordination': coordination, 'optimization': optimization, 'system_health': system_state.get('overall_health', 0.0), 'coordination_efficiency': coordination.get('coordination_efficiency', 0.0), 'optimization_success': optimization.get('optimization_success', False)}
        self.coordination_history.append(coordination_report)
        if len(self.coordination_history) > 100:
            self.coordination_history = self.coordination_history[-80:]
        return coordination_report

    def get_hierarchy_report(self) -> Dict[str, Any]:
        """Generate comprehensive hierarchy report"""
        if not self.agents:
            return {'status': 'no_agents'}
        level_distribution = defaultdict(int)
        role_distribution = defaultdict(int)
        for agent in self.agents.values():
            level_distribution[agent.level.value] += 1
            role_distribution[agent.role.value] += 1
        performance_metrics = {}
        if self.meta_agent:
            for (agent_id, agent) in self.agents.items():
                if agent_id != self.meta_agent.agent_id:
                    performance_metrics[agent_id] = self.meta_agent._analyze_agent_performance(agent)
        system_efficiency = self.meta_agent._calculate_system_efficiency(self.agents, self.tasks) if self.meta_agent else {'system_efficiency': 0.0}
        return {'total_agents': len(self.agents), 'level_distribution': dict(level_distribution), 'role_distribution': dict(role_distribution), 'performance_metrics': performance_metrics, 'system_efficiency': system_efficiency, 'coordination_history_size': len(self.coordination_history), 'optimization_history_size': len(self.optimization_history), 'hierarchy_depth': self._calculate_hierarchy_depth(), 'span_of_control': self._calculate_span_of_control()}

    def _calculate_hierarchy_depth(self) -> int:
        """Calculate the depth of the hierarchy"""
        max_depth = 0
        for agent in self.agents.values():
            depth = self._get_agent_depth(agent)
            max_depth = max(max_depth, depth)
        return max_depth

    def _get_agent_depth(self, agent: HierarchicalAgent, visited: Optional[Set[str]]=None) -> int:
        """Get depth of an agent in the hierarchy"""
        if visited is None:
            visited = set()
        if agent.agent_id in visited:
            return 0
        visited.add(agent.agent_id)
        if not agent.parent_agent:
            return 1
        parent = self.agents.get(agent.parent_agent)
        if parent:
            return 1 + self._get_agent_depth(parent, visited)
        return 1

    def _calculate_span_of_control(self) -> float:
        """Calculate average span of control"""
        total_children = sum((len(agent.child_agents) for agent in self.agents.values()))
        managers = len([agent for agent in self.agents.values() if agent.child_agents])
        return total_children / managers if managers > 0 else 0.0